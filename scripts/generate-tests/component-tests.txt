组件: ActionSheet
文件: packages/bui-core/src/ActionSheet/__tests__/ActionsSheet.test.tsx
========================================

import React from 'react';
import { act, isConformant, render, screen, userEvent } from 'testing';
import { ActionSheet, ActionSheetItem } from '../index';

describe('ActionSheet', () => {
  const rootClass = 'bui-action-sheet';
  beforeEach(() => {
    jest.useFakeTimers();
  });
  afterEach(() => {
    jest.clearAllTimers();
    jest.useRealTimers();
  });

  isConformant({
    Component: ActionSheet,
    displayName: 'BuiActionSheet',
    className: rootClass,
    requiredProps: {
      open: true,
    },
    getTargetElement: () => {
      return document.querySelector('.bui-action-sheet');
    },
  });
  it('renders correctly', async () => {
    const { container } = render(
      <ActionSheet open disablePortal extra="extra action item">
        <ActionSheetItem>action item copy</ActionSheetItem>
        <ActionSheetItem>action item edit</ActionSheetItem>
        <ActionSheetItem disabled>action item disabled</ActionSheetItem>
        <ActionSheetItem bold>action item bold</ActionSheetItem>
        <ActionSheetItem description="description">
          action item description
        </ActionSheetItem>
      </ActionSheet>,
    );
    await act(async () => {
      await jest.runAllTimers();
    });
    expect(container.firstChild).toMatchSnapshot();
  });
  it('should open and close', async () => {
    const { rerender } = render(
      <ActionSheet>
        <ActionSheetItem>action item copy</ActionSheetItem>
        <ActionSheetItem>action item edit</ActionSheetItem>
        <ActionSheetItem>action item delete</ActionSheetItem>
      </ActionSheet>,
    );
    expect(screen.queryAllByText(/action item/).length).toBe(0);
    rerender(
      <ActionSheet open>
        <ActionSheetItem>action item copy</ActionSheetItem>
        <ActionSheetItem>action item edit</ActionSheetItem>
        <ActionSheetItem>action item delete</ActionSheetItem>
      </ActionSheet>,
    );
    expect(screen.queryAllByText(/action item/).length).toBe(3);
  });
  it('should hide backdrop with hideBackdrop props', () => {
    render(
      <ActionSheet open hideBackdrop>
        <ActionSheetItem>action item copy</ActionSheetItem>
        <ActionSheetItem>action item edit</ActionSheetItem>
      </ActionSheet>,
    );
    expect(document.querySelector('.bui-backdrop')).not.toBeInTheDocument();
  });
  it('render extra element in first child', () => {
    render(
      <ActionSheet open extra="extra action item">
        <ActionSheetItem>action item copy</ActionSheetItem>
        <ActionSheetItem>action item edit</ActionSheetItem>
      </ActionSheet>,
    );
    const index = screen.getAllByText(/action item/).findIndex((item) => {
      return item.textContent === 'extra action item';
    });
    expect(index).toBe(0);
  });

  it('onClick can not be called when actions item disabled', () => {
    const onClick = jest.fn();
    render(
      <ActionSheet open>
        <ActionSheetItem>action item copy</ActionSheetItem>
        <ActionSheetItem disabled onClick={onClick} data-testid="disable-item">
          action item edit
        </ActionSheetItem>
      </ActionSheet>,
    );
    const disableItem = screen.getByTestId('disable-item');
    expect(disableItem).toHaveClass(`${rootClass}-item-disabled`);
    userEvent.click(disableItem);
    expect(onClick).not.toHaveBeenCalled();
  });

  it('actions item onclick function should be called', () => {
    const onClick = jest.fn();
    render(
      <ActionSheet open>
        <ActionSheetItem>action item copy</ActionSheetItem>
        <ActionSheetItem onClick={onClick}>action item edit</ActionSheetItem>
      </ActionSheet>,
    );
    userEvent.click(screen.getByText(/action item edit/));
    expect(onClick).toHaveBeenCalled();
  });

  it('actions item with bold can render correctly', () => {
    render(
      <ActionSheet open>
        <ActionSheetItem>action item copy</ActionSheetItem>
        <ActionSheetItem bold data-testid="bold-item">
          action item edit
        </ActionSheetItem>
      </ActionSheet>,
    );
    expect(screen.getByTestId('bold-item')).toHaveClass(
      `${rootClass}-item-bold`,
    );
  });
  it('actions item with description can render correctly', () => {
    render(
      <ActionSheet open>
        <ActionSheetItem>action item copy</ActionSheetItem>
        <ActionSheetItem description="description">
          action item edit
        </ActionSheetItem>
      </ActionSheet>,
    );
    expect(screen.getByText(/description/)).toHaveClass(
      `${rootClass}-item-description`,
    );
  });
  it.each([
    'primary',
    'warning',
    'success',
    'info',
    'danger',
    'default',
  ] as const)(
    'action item should render correctly with color props',
    (color) => {
      render(
        <ActionSheet open>
          <ActionSheetItem color={color} data-testid="color-item">
            action item edit
          </ActionSheetItem>
        </ActionSheet>,
      );
      expect(screen.getByTestId('color-item')).toHaveClass(
        `${rootClass}-item-${color}`,
      );
    },
  );
  it('action item triggers click event', () => {
    const onClick = jest.fn((_, { index }) => index);
    render(
      <ActionSheet open>
        <ActionSheetItem index={2} onClick={onClick}>
          action item edit
        </ActionSheetItem>
      </ActionSheet>,
    );
    userEvent.click(screen.getByText('action item edit'));
    expect(onClick).toHaveBeenCalled();
    expect(onClick).toReturnWith(2);
  });
  it('When action item triggers a click event onSelect will respond', () => {
    const onSelect = jest.fn((_, { index }) => index);
    render(
      <ActionSheet onSelect={onSelect} open>
        <ActionSheetItem index={1}>action item copy</ActionSheetItem>
        <ActionSheetItem index={2}>action item edit</ActionSheetItem>
      </ActionSheet>,
    );
    userEvent.click(screen.getByText('action item edit'));
    expect(onSelect).toHaveBeenCalled();
    expect(onSelect).toReturnWith(2);
  });

  it('last render cancelText', () => {
    render(
      <ActionSheet open cancelText="action item cancel">
        <ActionSheetItem>action item copy</ActionSheetItem>
        <ActionSheetItem bold>action item edit</ActionSheetItem>
      </ActionSheet>,
    );
    const actionItems = screen.getAllByText(/action item/);
    const index = actionItems.findIndex((item) => {
      return item.textContent === 'action item cancel';
    });
    expect(index).toBe(actionItems.length - 1);
    expect(document.querySelector(`.${rootClass}-cancel`)).toBeInTheDocument();
  });

  describe('handle onClose function', () => {
    it('onClose callback not work with default', () => {
      const onClose = jest.fn();
      render(
        <ActionSheet onClose={onClose} open>
          <ActionSheetItem>action item copy</ActionSheetItem>
          <ActionSheetItem>action item edit</ActionSheetItem>
        </ActionSheet>,
      );
      userEvent.click(screen.getByText(/action item edit/));
      expect(onClose).not.toHaveBeenCalled();
    });
    it('onClose should be called width closeOnAction equal true', () => {
      const onClose = jest.fn();
      render(
        <ActionSheet onClose={onClose} open cancelText="cancel">
          <ActionSheetItem>action item copy</ActionSheetItem>
          <ActionSheetItem>action item edit</ActionSheetItem>
        </ActionSheet>,
      );
      userEvent.click(screen.getByText('cancel'));
      expect(onClose).toHaveBeenCalled();
    });
  });
});


================================================================================

组件: Alert
文件: packages/bui-core/src/Alert/__tests__/Alert.test.tsx
========================================

import React from 'react';
import { render, isConformant, userEvent, screen } from 'testing';
import Alert from '../Alert';

describe('Alert', () => {
  isConformant({
    Component: Alert,
    displayName: 'BuiAlert',
    className: 'bui-alert',
  });
  describe('prop: message', () => {
    it('should  render message current', () => {
      const component = <Alert>warning alert!!</Alert>;
      const { container } = render(component);
      expect(container).toHaveTextContent('warning alert!!');
    });
  });
  describe('prop: type', () => {
    it('should render primary by default', () => {
      const component = <Alert>warning alert!!</Alert>;
      const { container } = render(component);
      expect(container.firstChild).toHaveClass('bui-alert-standard-primary');
    });
    it.each(['danger', 'info', 'warning', 'success', 'primary'] as const)(
      'should render type current',
      (color) => {
        const component = <Alert color={color}>warning alert!!</Alert>;
        const { container } = render(component);
        expect(container.firstChild).toHaveClass(`bui-alert-standard-${color}`);
      },
    );
  });
  describe('prop: icon', () => {
    it('should  render icon default', () => {
      const component = <Alert>warning alert!!</Alert>;
      render(component);
      expect(document.querySelector('.bui-alert-default-icon')).toBeTruthy();
    });
    it('should not render icon when it is false', () => {
      const component = <Alert icon={false}>warning alert!!</Alert>;
      render(component);
      expect(document.querySelector('.bui-icon')).toBeFalsy();
    });
    it('should render icon current', () => {
      const component = <Alert icon="close">warning alert!!</Alert>;
      const { container } = render(component);
      expect(container).toHaveTextContent('close');
    });
    it('should render icon current in miniapp', async () => {
      jest.resetModules();
      jest.doMock('@bifrostui/utils', () => ({
        isMini: true,
      }));
      const { default: MiniAlert } = await import('../index');
      const component = <MiniAlert>warning alert!!</MiniAlert>;
      const { container } = render(component);
      expect(container.querySelector('.bui-alert-default-icon')).toBeTruthy();
    });
    it('should render icon color current in miniapp', async () => {
      jest.resetModules();
      jest.doMock('@bifrostui/utils', () => ({
        isMini: true,
      }));
      const { default: MiniAlert } = await import('../index');
      const component = <MiniAlert color="success">warning alert!!</MiniAlert>;
      const { container } = render(component);
      expect(
        container.querySelector('.bui-alert-standard-success'),
      ).toBeTruthy();
    });
    it('should render with marquee current', () => {
      render(
        <Alert marquee>
          【开始】首部海外维和题材商业大片高燃来袭，聚焦中国维和警察鲜为人知的生死时刻！【结束】
        </Alert>,
      );
      expect(document.querySelector('.bui-alert-marquee')).toBeTruthy();
    });
  });

  describe('action', () => {
    it('should close alert when click close', () => {
      const onClose = jest.fn();
      render(<Alert onClose={onClose}>warning alert!!</Alert>);
      userEvent.click(document.querySelector('.bui-alert-action'));
      expect(onClose).toHaveBeenCalled();
    });
    it('should render action current', () => {
      const component = <Alert action={<div>close</div>}>warning alert</Alert>;
      render(component);
      expect(screen.getByText(/close/)).toBeTruthy();
      expect(document.querySelector('.bui-alert-action')).toBeTruthy();
    });
  });
});


================================================================================

组件: Avatar
文件: packages/bui-core/src/Avatar/__tests__/Avatar.test.tsx
========================================

import React from 'react';
import { isConformant, render, screen, userEvent } from 'testing';
import Avatar from '../Avatar';

const classPrefix = 'bui-avatar';

describe('Avatar', () => {
  isConformant({
    Component: Avatar,
    displayName: 'BuiAvatar',
    className: 'bui-avatar',
  });
  describe('prop: src', () => {
    it('should render children correctly, not src', () => {
      const component = (
        <Avatar src="https://gw.alicdn.com/imgextra/i3/O1CN01tp2YUs1WFD8lboMDu_!!6000000002758-2-tps-126-126.png">
          hello world
        </Avatar>
      );
      const { container } = render(component);

      expect(screen.getByText('hello world')).toBeTruthy();
      expect(screen.queryByRole('img')).toBe(null);
      expect(container).toMatchSnapshot();
    });

    it('should render containing an img', () => {
      const component = (
        <Avatar src="https://gw.alicdn.com/imgextra/i3/O1CN01tp2YUs1WFD8lboMDu_!!6000000002758-2-tps-126-126.png" />
      );
      const { container } = render(component);

      expect(screen.getByRole('img')).toHaveAttribute(
        'src',
        'https://gw.alicdn.com/imgextra/i3/O1CN01tp2YUs1WFD8lboMDu_!!6000000002758-2-tps-126-126.png',
      );
      expect(container).toMatchSnapshot();
    });
  });

  describe('prop: size', () => {
    it.each(['xsmall', 'small', 'medium', 'large'] as const)(
      'should render size correct',
      (size) => {
        render(<Avatar size={size} data-testid="avatar" />);
        expect(screen.getByTestId('avatar')).toHaveClass(
          `${classPrefix}-${size}`,
        );
      },
    );
  });

  describe('prop: variant', () => {
    it('should render rounded default correctly', () => {
      render(<Avatar data-testid="avatar" />);
      expect(screen.getByTestId('avatar')).toHaveClass(
        `${classPrefix}-rounded`,
      );
    });
    it('should render square correctly', () => {
      render(<Avatar variant="square" data-testid="avatar" />);
      expect(screen.getByTestId('avatar')).toHaveClass(`${classPrefix}-square`);
    });
  });

  describe('prop: ImageProps', () => {
    render(
      <Avatar src="https://not.exists.image/" ImageProps={{ fit: 'fill' }} />,
    );
    expect(screen.getByRole('img').style.objectFit === 'fill');
  });
  // it('has placeholder', async () => {
  //   render(<Avatar src="https://not.exists.image/" placeholder="加载失败" />);
  //   expect(screen.getByText('加载失败')).toBeTruthy();
  // });

  it.each(['contain', 'cover', 'fill', 'none', 'scale-down'])(
    'renders with different fit modes',
    async (fit: any) => {
      render(
        <Avatar
          src="https://gw.alicdn.com/imgextra/i3/O1CN01tp2YUs1WFD8lboMDu_!!6000000002758-2-tps-126-126.png"
          fit={fit}
        />,
      );
      expect(screen.getByRole('img').style.objectFit === fit);
    },
  );

  describe('events', () => {
    it('responses click events', () => {
      const onClick = jest.fn();
      render(<Avatar onClick={onClick}>hello world</Avatar>);
      userEvent.click(screen.getByText('hello world'));
      expect(onClick).toHaveBeenCalled();
    });
  });
});


================================================================================

组件: Backdrop
文件: packages/bui-core/src/Backdrop/__test__/Backdrop.test.tsx
========================================

import React from 'react';
import { render, fireEvent } from 'testing';
import Backdrop from '../Backdrop';

describe('Backdrop', () => {
  const classPrefix = 'bui-backdrop';

  it('should fire onClick event when click backdrop', () => {
    const clickFn = jest.fn();
    const { container } = render(
      <Backdrop open timeout={1000} onClick={clickFn} />,
    );
    const [backdrop] = [...container.getElementsByClassName(classPrefix)];
    fireEvent.click(backdrop);
    expect(clickFn).toBeCalled();
  });

  it('should pass transitionDuration', () => {
    const { container } = render(<Backdrop open timeout={2341} />);
    expect(container.querySelector(`.${classPrefix}`)).toHaveStyle(
      'transition: opacity 2341ms cubic-bezier(0.4, 0, 0.6, 1) 0ms',
    );
  });

  it('can be invisible', () => {
    const { container } = render(<Backdrop open timeout={1000} invisible />);
    expect(container.querySelector(`.${classPrefix}`)).toHaveClass(
      `${classPrefix}-invisible`,
    );
    const { container: container1 } = render(<Backdrop open timeout={1000} />);
    expect(container1.querySelector(`.${classPrefix}`)).not.toHaveClass(
      `${classPrefix}-invisible`,
    );
  });
});


================================================================================

组件: Badge
文件: packages/bui-core/src/Badge/__tests__/Badge.test.tsx
========================================

import React from 'react';
import { isConformant, render } from 'testing';
import Badge from '..';

const classPrefix = 'bui-badge';
describe('Badge', () => {
  isConformant({
    Component: Badge,
    displayName: 'BuiBadge',
    className: 'bui-badge',
  });
  describe('prop: content', () => {
    it('render with badgeContent', () => {
      const { container } = render(<Badge content="12" />);
      expect(container).toHaveTextContent('12');
    });
    it('should be type of ReactNode', () => {
      const { container } = render(<Badge content={<div>content</div>} />);
      expect(container.firstChild.childNodes[0]).toBeInstanceOf(HTMLElement);
    });
    it('should not render content when it is zero', () => {
      const { getByTestId } = render(
        <Badge data-testid="t-badge" content={0} />,
      );
      expect(getByTestId('t-badge').firstChild).not.toBe(0);
    });
  });
  describe('prop: color', () => {
    it.each(['success', 'primary', 'info'] as const)(
      'render color current',
      (color) => {
        const { container } = render(<Badge color={color} content="1" />);
        expect(container.firstChild.childNodes[0]).toHaveClass(
          `${classPrefix}-${color}`,
        );
      },
    );
    it('should render width default color primary', () => {
      const { container } = render(<Badge content="1" />);
      expect(container.firstChild.childNodes[0]).toHaveClass(
        `${classPrefix}-primary`,
      );
    });
  });
  describe('prop: maxCount', () => {
    it('render with maxCount current', () => {
      const { container } = render(<Badge maxCount={100} content="988" />);
      expect(container).toHaveTextContent('100+');
    });
  });
  describe('prop: type', () => {
    it.each(['dot', 'standard', 'bubble'] as const)(
      'render type current',
      (type) => {
        const { container } = render(<Badge type={type} content="12" />);
        expect(container.firstChild.childNodes[0]).toHaveClass(
          `${classPrefix}-${type}`,
        );
      },
    );
  });
});


================================================================================

组件: Breadcrumb
文件: packages/bui-core/src/Breadcrumb/__tests__/Breadcrumb.test.tsx
========================================

import React from 'react';
import { render, isConformant, userEvent, screen } from 'testing';
import Breadcrumb, { BreadcrumbItem, BreadcrumbProps } from '../index';

const setup = (props: BreadcrumbProps) => {
  const component = render(<Breadcrumb {...props} />);
  return {
    ...component,
  };
};

const setupByElement = (props: BreadcrumbProps, itemNum = 2) => {
  const component = render(
    <Breadcrumb {...props}>
      {itemNum
        ? Array(itemNum)
            .fill('')
            .map((item, index) => {
              return (
                <BreadcrumbItem key={`${index + 1}`}>
                  路径{index + 1}
                </BreadcrumbItem>
              );
            })
        : null}
    </Breadcrumb>,
  );
  return {
    ...component,
  };
};

const items: Array<{
  title: string;
  separator?: string;
}> = [
  {
    title: '路径1',
  },
  {
    title: '路径2',
  },
];

describe('Breadcrumb', () => {
  isConformant({
    Component: Breadcrumb,
    displayName: 'BuiBreadcrumb',
    className: 'bui-breadcrumb',
    requiredProps: {
      items,
    },
  });

  it('should render children', () => {
    const { container } = setup({
      items,
    });
    const firstRouteItem = container.querySelectorAll(
      '.bui-breadcrumb-item',
    )[0];
    const secondRouteItem = container.querySelectorAll(
      '.bui-breadcrumb-item',
    )[1];
    const separator = container.querySelectorAll(
      '.bui-breadcrumb-item-separator',
    )[0];
    expect(firstRouteItem).toHaveTextContent('路径1');
    expect(secondRouteItem).toHaveTextContent('路径2');
    expect(separator).toHaveTextContent('/');
  });
  it('should render custom separator', () => {
    const { container } = setup({
      items,
      separator: '>',
    });
    const firstRouteItem = container.querySelectorAll(
      '.bui-breadcrumb-item',
    )[0];
    const secondRouteItem = container.querySelectorAll(
      '.bui-breadcrumb-item',
    )[1];
    const separator = container.querySelectorAll(
      '.bui-breadcrumb-item-separator',
    )[0];
    expect(firstRouteItem).toHaveTextContent('路径1');
    expect(secondRouteItem).toHaveTextContent('路径2');
    expect(separator).toHaveTextContent('>');
  });
  it('should render item custom separator', () => {
    const { container } = setup({
      items: [
        {
          ...items[0],
          separator: ':',
        },
        items[1],
      ],
      separator: ':',
    });
    const separator = container.querySelectorAll(
      '.bui-breadcrumb-item-separator',
    )[0];
    expect(separator).toHaveTextContent(':');
  });
  it('should trigger item onClick', () => {
    const fakeClick = jest.fn();
    setup({
      items: [
        {
          ...items[0],
          onClick: fakeClick,
        },
        items[1],
      ],
      separator: ':',
    });
    userEvent.click(screen.getByText('路径1'));
    expect(fakeClick).toBeCalled();
  });
  it('should return null', () => {
    const { container } = setup({});

    expect(container.firstChild).toBeNull();
  });

  describe('CollapsePanelItem', () => {
    it('should render children', () => {
      const { container } = setupByElement({});
      const firstRouteItem = container.querySelectorAll(
        '.bui-breadcrumb-item',
      )[0];
      const secondRouteItem = container.querySelectorAll(
        '.bui-breadcrumb-item',
      )[1];
      const separator = container.querySelectorAll(
        '.bui-breadcrumb-item-separator',
      )[0];
      expect(firstRouteItem).toHaveTextContent('路径1');
      expect(secondRouteItem).toHaveTextContent('路径2');
      expect(separator).toHaveTextContent('/');
    });
    it('should render custom separator', () => {
      const { container } = setupByElement({
        separator: '>',
      });
      const firstRouteItem = container.querySelectorAll(
        '.bui-breadcrumb-item',
      )[0];
      const secondRouteItem = container.querySelectorAll(
        '.bui-breadcrumb-item',
      )[1];
      const separator = container.querySelectorAll(
        '.bui-breadcrumb-item-separator',
      )[0];
      expect(firstRouteItem).toHaveTextContent('路径1');
      expect(secondRouteItem).toHaveTextContent('路径2');
      expect(separator).toHaveTextContent('>');
    });
    it('should render item custom separator', () => {
      const { container } = render(
        <Breadcrumb>
          <BreadcrumbItem separator=":">路径1</BreadcrumbItem>
          <BreadcrumbItem>路径2</BreadcrumbItem>
        </Breadcrumb>,
      );
      const separator = container.querySelectorAll(
        '.bui-breadcrumb-item-separator',
      )[0];
      expect(separator).toHaveTextContent(':');
    });
    it('should trigger item onClick', () => {
      const fakeClick = jest.fn();
      render(
        <Breadcrumb>
          <BreadcrumbItem onClick={fakeClick}>路径1</BreadcrumbItem>
          <BreadcrumbItem>路径2</BreadcrumbItem>
        </Breadcrumb>,
      );
      userEvent.click(screen.getByText('路径1'));
      expect(fakeClick).toBeCalled();
    });
    it('should return null', () => {
      const { container } = setupByElement({}, 0);

      expect(container.firstChild).toBeNull();
    });
  });
});


================================================================================

组件: Button
文件: packages/bui-core/src/Button/__tests__/Button.test.tsx
========================================

import React from 'react';
import { isConformant, render, screen, userEvent } from 'testing';
import Button from '../index';

describe('Button', () => {
  const rootClass = 'bui-btn';

  isConformant({
    Component: Button,
    displayName: 'BuiButton',
    className: rootClass,
  });
  it('renders correctly', () => {
    const { container } = render(<Button>button</Button>);
    expect(container.firstChild).toMatchSnapshot();
  });

  it('default render is medium outlined', () => {
    render(<Button>button</Button>);
    expect(screen.getByRole('button')).toHaveClass(
      `${rootClass}-outlined ${rootClass}-medium`,
    );
  });

  it('can trigger a function by being clicked', () => {
    const onClick = jest.fn();
    render(<Button onClick={onClick}>This is a button</Button>);
    userEvent.click(screen.getByRole('button'));
    expect(onClick).toHaveBeenCalled();
  });
  it('does not trigger a function when render a disabled button', () => {
    const onClick = jest.fn();
    render(<Button disabled>disabled button</Button>);
    const disabledBtn = screen.getByRole('button');
    expect(disabledBtn).toHaveClass(`${rootClass}-disabled`);
    userEvent.click(disabledBtn);
    expect(onClick).not.toHaveBeenCalled();
  });
  it.each([
    'primary',
    'warning',
    'success',
    'info',
    'danger',
    'vip',
    'default',
  ] as const)('should render correctly with color props', (color) => {
    render(<Button color={color}>{color} button</Button>);
    expect(screen.getByRole('button')).toHaveClass(`${rootClass}-${color}`);
  });
  it.each(['full', 'large', 'medium', 'medium'] as const)(
    'should render correctly with size props',
    (size) => {
      render(<Button size={size}>{size} button</Button>);
      expect(screen.getByRole('button')).toHaveClass(`${rootClass}-${size}`);
    },
  );

  it('should render a button with startIcon', () => {
    render(<Button startIcon={<span>icon</span>}>button</Button>);
    expect(screen.queryByText('icon')).toBeInTheDocument();
  });
  it('should render a button with endIcon', () => {
    render(<Button endIcon={<span>endIcon</span>}>button</Button>);
    expect(screen.queryByText('endIcon')).toBeInTheDocument();
  });
});


================================================================================

组件: Calendar
文件: packages/bui-core/src/Calendar/__tests__/Calendar.test.tsx
========================================

```tsx
import React from 'react';
import { isConformant, render, screen, userEvent, waitFor } from 'testing';
import dayjs from 'dayjs';
import Calendar from '../index';

describe('Calendar', () => {
  const rootClass = 'bui-calendar';

  isConformant({
    Component: Calendar,
    displayName: 'BuiCalendar',
    className: rootClass,
  });

  it('renders correctly', () => {
    const { container } = render(<Calendar />);
    expect(container.firstChild).toMatchSnapshot();
  });

  it('renders with correct default props', () => {
    render(<Calendar />);
    expect(screen.getByText(dayjs().format('YYYY/MM'))).toBeInTheDocument();
    expect(document.querySelector(`.${rootClass}`)).toHaveAttribute('data-mode', 'single');
  });

  it('renders with custom header format', () => {
    const customFormat = 'MM/YYYY';
    render(<Calendar headerBarFormat={customFormat} />);
    expect(screen.getByText(dayjs().format(customFormat))).toBeInTheDocument();
  });

  it('handles month navigation correctly', async () => {
    const onMonthChange = jest.fn();
    render(<Calendar onMonthChange={onMonthChange} />);

    const currentMonth = dayjs().format('YYYY/MM');
    expect(screen.getByText(currentMonth)).toBeInTheDocument();

    // Click next month button
    const nextButton = document.querySelectorAll(`.${rootClass}-handler-btn`)[1];
    userEvent.click(nextButton);

    const nextMonth = dayjs().add(1, 'month').format('YYYY/MM');
    await waitFor(() => {
      expect(screen.getByText(nextMonth)).toBeInTheDocument();
      expect(onMonthChange).toHaveBeenCalledWith(expect.anything(), {
        type: 'next',
        month: nextMonth,
      });
    });

    // Click previous month button
    const prevButton = document.querySelectorAll(`.${rootClass}-handler-btn`)[0];
    userEvent.click(prevButton);

    await waitFor(() => {
      expect(screen.getByText(currentMonth)).toBeInTheDocument();
      expect(onMonthChange).toHaveBeenCalledWith(expect.anything(), {
        type: 'prev',
        month: currentMonth,
      });
    });
  });

  it('selects a date in single mode', () => {
    const onChange = jest.fn();
    render(<Calendar onChange={onChange} />);

    // Find a non-disabled day in the current month
    const days = document.querySelectorAll(`.${rootClass}-day:not(.${rootClass}-disabled)`);
    userEvent.click(days[10]);

    expect(onChange).toHaveBeenCalled();
    expect(onChange.mock.calls[0][1]).toBeInstanceOf(Date);
  });

  it('selects a date range in range mode', async () => {
    const onChange = jest.fn();
    render(<Calendar mode="range" onChange={onChange} />);

    // Find non-disabled days in the current month
    const days = document.querySelectorAll(`.${rootClass}-day:not(.${rootClass}-disabled)`);

    // Select start date
    userEvent.click(days[5]);
    expect(onChange).toHaveBeenCalledTimes(1);
    expect(onChange.mock.calls[0][1]).toEqual([expect.any(Date), null]);

    // Select end date
    userEvent.click(days[10]);
    expect(onChange).toHaveBeenCalledTimes(2);
    expect(onChange.mock.calls[1][1]).toEqual([expect.any(Date), expect.any(Date)]);
  });

  it('handles disabled dates correctly', () => {
    const disabledDate = (date) => dayjs(date).date() === 15;
    const onChange = jest.fn();

    render(<Calendar disabledDate={disabledDate} onChange={onChange} />);

    // Find the disabled day (15th of the month)
    const day15 = screen.getByText('15').closest(`.${rootClass}-day-box`);
    userEvent.click(day15);

    expect(onChange).not.toHaveBeenCalled();
  });

  it('highlights today correctly', () => {
    render(<Calendar highlightDate="today" />);

    const today = dayjs().date().toString();
    const todayElement = screen.getByText(today);

    expect(todayElement.closest(`.${rootClass}-day`)).toHaveClass(`${rootClass}-today`);
  });

  it('highlights weekends correctly', () => {
    render(<Calendar highlightDate="weekend" />);

    expect(document.querySelector(`.${rootClass}`)).toHaveClass(`${rootClass}-highlight-weekend`);
  });

  it('renders with custom date renderer', () => {
    const dateRender = (ins) => (
      <div data-testid="custom-date">{ins.day && dayjs(ins.day).date()}</div>
    );

    render(<Calendar dateRender={dateRender} />);

    expect(screen.getAllByTestId('custom-date').length).toBeGreaterThan(0);
  });

  it('renders with custom week renderer', () => {
    const weekRender = (weekday) => <div data-testid="custom-week">{weekday}</div>;

    render(<Calendar weekRender={weekRender} />);

    expect(screen.getAllByTestId('custom-week').length).toBe(7);
  });

  it('renders with min and max date constraints', () => {
    const minDate = dayjs().subtract(1, 'month').toDate();
    const maxDate = dayjs().add(2, 'month').toDate();

    render(<Calendar minDate={minDate} maxDate={maxDate} />);

    // Navigate to previous month (should be allowed)
    const prevButton = document.querySelectorAll(`.${rootClass}-handler-btn`)[0];
    userEvent.click(prevButton);

    expect(screen.getByText(dayjs().subtract(1, 'month').format('YYYY/MM'))).toBeInTheDocument();

    // Try to navigate before min date (should be disabled)
    userEvent.click(prevButton);

    // Should still be on the min date month
    expect(screen.getByText(dayjs().subtract(1, 'month').format('YYYY/MM'))).toBeInTheDocument();
  });

  it('handles hideDaysOutsideCurrentMonth correctly', () => {
    const { rerender } = render(<Calendar hideDaysOutsideCurrentMonth={false} />);

    // With hideDaysOutsideCurrentMonth=false, should show days from adjacent months
    const initialDays = document.querySelectorAll(`.${rootClass}-day`);
    const initialDaysWithContent = Array.from(initialDays).filter(day => day.textContent?.trim());

    rerender(<Calendar hideDaysOutsideCurrentMonth={true} />);

    // With hideDaysOutsideCurrentMonth=true, should hide days from adjacent months
    const updatedDays = document.querySelectorAll(`.${rootClass}-day`);
    const updatedDaysWithContent = Array.from(updatedDays).filter(day => day.textContent?.trim());

    expect(updatedDaysWithContent.length).toBeLessThan(initialDaysWithContent.length);
  });
});
```

================================================================================

组件: Card
文件: packages/bui-core/src/Card/__tests__/Card.test.tsx
========================================

import React, { ReactElement } from 'react';
import { render, isConformant, fireEvent } from 'testing';
import { CloseIcon } from '@bifrostui/icons';
import Card, { CardContent, CardHeader } from '../index';
import { CardProps } from '../Card.types';

const setup = (props: CardProps, children: ReactElement) => {
  const component = render(
    <Card data-testid="card" {...props}>
      {children}
    </Card>,
  );
  const tag = component.getByTestId('card');
  return {
    tag,
    ...component,
  };
};

describe('Card', () => {
  isConformant({
    Component: Card,
    displayName: 'BuiCard',
    className: 'bui-card',
    skip: ['component-has-root-ref', 'component-has-displayname'],
  });
  it('should, render children', () => {
    const { getByTestId } = setup(
      {},
      <>
        <CardHeader data-testid="card-header" title="卡片标题" />
        <CardContent data-testid="card-content">卡片正文</CardContent>
      </>,
    );
    expect(getByTestId('card-header')).toHaveTextContent('卡片标题');
    expect(getByTestId('card-content')).toHaveTextContent('卡片正文');
  });
  describe('CardHeader', () => {
    it('should render title current', () => {
      const { getByTestId } = render(
        <>
          <Card>
            <CardHeader data-testid="title-1" title="卡片标题" />
          </Card>
          <Card>
            <CardHeader data-testid="title-2" title={<div>卡片标题</div>} />
          </Card>
        </>,
      );
      expect(getByTestId('title-1')).toHaveTextContent('卡片标题');
      expect(getByTestId('title-2')).toHaveTextContent('卡片标题');
    });
    it('should render subtitle current', () => {
      const { getByTestId } = render(
        <>
          <Card>
            <CardHeader
              data-testid="subtitle-1"
              title="标题"
              subtitle="卡片副标题"
            />
          </Card>
          <Card>
            <CardHeader
              data-testid="subtitle-2"
              title="标题"
              subtitle={<div>卡片副标题</div>}
            />
          </Card>
        </>,
      );
      expect(getByTestId('subtitle-1')).toHaveTextContent('卡片副标题');
      expect(getByTestId('subtitle-2')).toHaveTextContent('卡片副标题');
    });
    it('should render extra current', () => {
      const { getByTestId } = render(
        <>
          <Card>
            <CardHeader data-testid="extra-1" extra=">" title="title1" />
          </Card>
          <Card>
            <CardHeader
              data-testid="extra-2"
              title="title2"
              extra={<div>close</div>}
            />
          </Card>
        </>,
      );
      expect(getByTestId('extra-1')).toHaveTextContent('>');
      expect(getByTestId('extra-2')).toHaveTextContent('close');
    });
    describe('prop: endIcon', () => {
      it('should has default endIcon', () => {
        const { container } = render(
          <Card>
            <CardHeader
              title="卡片标题"
              onClick={() => {
                console.log('hello');
              }}
            />
          </Card>,
        );
        const element = container.getElementsByClassName('bui-svg-icon');
        expect(element.length).toBe(1);
      });
      it('should not render endIcon when it is false', () => {
        const { container } = render(
          <Card>
            <CardHeader title="卡片标题" endIcon="false" />
          </Card>,
        );
        const element = container.getElementsByClassName('bui-svg-icon');
        expect(element.length).toBe(0);
      });
      it('should render endIcon current', () => {
        const { container } = render(
          <Card>
            <CardHeader
              title="卡片标题"
              endIcon={<CloseIcon className="close-icon" />}
            />
          </Card>,
        );
        const element = container.getElementsByClassName('close-icon');
        expect(element.length).toBe(1);
      });
    });
    describe('action', () => {
      it('title click', () => {
        const onClick = jest.fn();
        const { getByTestId } = render(
          <Card>
            <CardHeader
              data-testid="t-header"
              title="卡片标题"
              onClick={onClick}
            />
          </Card>,
        );

        fireEvent.click(getByTestId('t-header'));
        expect(onClick).toHaveBeenCalled();
      });
      // it('extra click', () => {
      //   const onClick = jest.fn();
      //   const { getByTestId } = render(
      //     <Card>
      //       <CardHeader
      //         data-testid="t-header"
      //         title="卡片标题"
      //         extra="close"
      //         onExtraClick={onClick}
      //       />
      //     </Card>,
      //   );

      //   fireEvent.click(getByTestId('t-header').lastChild);
      //   expect(onClick).toHaveBeenCalled();
      // });
    });
  });
});


================================================================================

组件: Checkbox
文件: packages/bui-core/src/Checkbox/__tests__/Checkbox.test.tsx
========================================

import React, { useState } from 'react';
import { act, fireEvent, isConformant, render, screen } from 'testing';
import { Checkbox, CheckboxGroup } from '..';

describe('Checkbox', () => {
  const rootClass = 'bui-checkbox';

  isConformant({
    className: rootClass,
    displayName: 'BuiCheckbox',
    Component: Checkbox,
  });

  it('should be checked', () => {
    render(<Checkbox checked>Checkbox</Checkbox>);
    const checkbox = screen.getByRole<HTMLInputElement>('checkbox');
    expect(checkbox.checked).toBeTruthy();
  });

  it('should have value property', () => {
    render(<Checkbox value="checkbox">Checkbox</Checkbox>);
    const checkbox = screen.getByRole<HTMLInputElement>('checkbox');
    expect(checkbox.value).toBe('checkbox');
  });

  it('should have name property', () => {
    render(<Checkbox name="checkbox">Checkbox</Checkbox>);
    const checkbox = screen.getByRole<HTMLInputElement>('checkbox');
    expect(checkbox.name).toBe('checkbox');
  });

  it('should disabled', () => {
    render(
      <Checkbox disabled data-testid="checkbox">
        Checkbox
      </Checkbox>,
    );
    expect(screen.getByTestId('checkbox')).toHaveClass(`${rootClass}-disabled`);
    expect(screen.getByRole('checkbox')).toHaveAttribute('disabled');
  });

  it('should use custom unchecked icon', () => {
    const uncheckedIcon = <div className="test-unchecked-icon">icon</div>;
    render(<Checkbox icon={uncheckedIcon} />);
    const icon = screen.getByText('icon');
    expect(icon).toBeVisible();
  });

  it('should use custom checked icon', () => {
    const checkedIcon = <div className="test-checked-icon">icon</div>;
    render(<Checkbox checkedIcon={checkedIcon} checked />);
    const icon = screen.getByText('icon');
    expect(icon).toBeVisible();
  });

  describe('Checkbox label placement', () => {
    const labelPlacements = ['top', 'bottom', 'left', 'right'] as const;
    labelPlacements.forEach((placement) => {
      it(`label should on the ${placement}`, () => {
        const { getByTestId } = render(
          <Checkbox data-testid={rootClass} labelPlacement={placement}>
            Checkbox
          </Checkbox>,
        );
        const checkbox = getByTestId(rootClass);
        expect(checkbox).toMatchSnapshot();
      });
    });
  });

  it('should call `onChange`', () => {
    const fakeChange = jest.fn((e) => e.target.value);
    function Component() {
      const [value] = useState('淘票票');
      const [checked] = useState(false);
      return (
        <Checkbox
          inputProps={{
            className: `${rootClass}-test`,
          }}
          checked={checked}
          value={value}
          onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
            fakeChange(e);
          }}
        >
          淘票票
        </Checkbox>
      );
    }
    const { container } = render(<Component />);
    const checkbox = container.querySelector(`.${rootClass}-test`);
    fireEvent.click(checkbox);
    expect(fakeChange).toBeCalled();
  });

  describe('CheckboxGroup', () => {
    it('value should be controled by `value` property', () => {
      function Component() {
        const [value] = useState(['淘票票', '喜洋洋']);
        return (
          <CheckboxGroup value={value}>
            <Checkbox value="水门桥">水门桥</Checkbox>
            <Checkbox value="淘票票">淘票票</Checkbox>
            <Checkbox value="喜洋洋">喜洋洋</Checkbox>
          </CheckboxGroup>
        );
      }

      const { container } = render(<Component />);
      const checkboxList = container.querySelectorAll<HTMLInputElement>(
        `.${rootClass}-input`,
      );
      expect(checkboxList[0].checked).toBeFalsy();
      expect(checkboxList[1].checked).toBeTruthy();
      expect(checkboxList[2].checked).toBeTruthy();
    });

    it('should call `onChange`', () => {
      const fakeChange = jest.fn((e, data) => data.value);
      const { container } = render(
        <CheckboxGroup value={[]} onChange={fakeChange}>
          <Checkbox value="水门桥">水门桥</Checkbox>
          <Checkbox value="淘票票">淘票票</Checkbox>
          <Checkbox value="喜洋洋">喜洋洋</Checkbox>
        </CheckboxGroup>,
      );
      const checkboxList = container.querySelectorAll(`.${rootClass}-input`);
      fireEvent.click(checkboxList[1]);
      expect(fakeChange).toReturnWith(['淘票票']);
    });

    it('should be cancel selected', () => {
      const fakeChange = jest.fn((e, { value }) => value);
      const { container } = render(
        <CheckboxGroup value={['淘票票']} onChange={fakeChange}>
          <Checkbox value="水门桥">水门桥</Checkbox>
          <Checkbox value="淘票票">淘票票</Checkbox>
          <Checkbox value="喜洋洋">喜洋洋</Checkbox>
        </CheckboxGroup>,
      );

      act(() => {
        const checkboxList = container.querySelectorAll(`.${rootClass}-input`);
        fireEvent.click(checkboxList[1]);
        expect(fakeChange).toReturnWith([]);
      });
    });

    it('should disabled', () => {
      const { container } = render(
        <CheckboxGroup disabled>
          <Checkbox value="水门桥">水门桥</Checkbox>
          <Checkbox value="淘票票">淘票票</Checkbox>
          <Checkbox value="喜洋洋">喜洋洋</Checkbox>
        </CheckboxGroup>,
      );
      const checkboxList = container.querySelectorAll<HTMLInputElement>(
        `.${rootClass}-input`,
      );
      checkboxList.forEach((item) => {
        expect(item.disabled).toBeTruthy();
      });
    });
  });
});


================================================================================

组件: CitySelector
文件: packages/bui-core/src/CitySelector/__tests__/CitySelector.test.tsx
========================================

import React from 'react';
import {
  screen,
  isConformant,
  render,
  userEvent,
  fireEvent,
  waitFor,
} from 'testing';
import CitySelector from '../CitySelector';

const cities = require('./cities.json');
const hotCities = require('./hotCities.json');

const selectedCity = { code: '310100', name: '上海' };
const selectedCityGroupName = '当前城市';
const currentCity = { code: '310100', name: '上海' };
const currentCityGroupName = '定位城市';
const hotCitiesGroupName = '热门城市';
const title = '选择城市';
const onSelect = jest.fn();
const onClose = jest.fn();

const queryEle = (container, selector) => {
  return container.querySelector(selector);
};

describe('CitySelector', () => {
  isConformant({
    Component: CitySelector,
    displayName: 'BuiCitySelector',
    className: 'bui-city-selector',
    skip: ['component-has-root-ref'],
    requiredProps: {
      cities,
    },
  });
  describe('prop: content', () => {
    it('render with citySelector', async () => {
      const { container } = render(
        <CitySelector
          cities={cities}
          onSelect={onSelect}
          selectedCity={selectedCity}
          selectedCityGroupName={selectedCityGroupName}
          currentCity={currentCity}
          currentCityGroupName={currentCityGroupName}
          hotCities={hotCities}
          hotCitiesGroupName={hotCitiesGroupName}
          disableIndex={false}
          title={title}
          onClose={onClose}
        />,
      );

      expect(queryEle(container, '#CRRT')).toBeInTheDocument();
      expect(queryEle(container, '#GPS')).toBeInTheDocument();
      expect(queryEle(container, '#HOT')).toBeInTheDocument();
      expect(
        queryEle(container, '.bui-city-selector-list-container'),
      ).toBeInTheDocument();
      expect(
        queryEle(container, '.bui-city-selector-title'),
      ).toBeInTheDocument();
      userEvent.click(container.querySelector('.bui-city-selector-btn-close'));
      expect(onClose).toHaveBeenCalledTimes(1);
      userEvent.click(
        container.querySelector(
          '.bui-city-selector-list-container .bui-city-selector-list-item',
        ),
      );
      expect(onSelect).toHaveBeenCalledTimes(1);

      userEvent.click(container.querySelector('.bui-city-selector-item'));
      expect(onSelect).toHaveBeenCalledTimes(2);

      const $scrollView = container.querySelector(
        `.bui-city-selector-scroll-view-container`,
      );
      fireEvent.scroll($scrollView, {
        target: { scrollTop: 200 },
      });
      expect($scrollView.scrollTop).toBe(200);

      await waitFor(() => {
        userEvent.click(
          container.querySelector(
            '.bui-city-selector-index-item[data-code="D"]',
          ),
        );
        const cityText = screen.getByText('大连');
        expect(cityText).toBeVisible();

        const cityCodeS = container.querySelector(
          '.bui-city-selector-index-item[data-code="S"]',
        );
        const mockElementFromPoint = jest.fn(() => cityCodeS);
        // 替换原生函数
        Object.defineProperty(document, 'elementFromPoint', {
          value: mockElementFromPoint,
          writable: true,
        });
        const $codeContainer = queryEle(
          container,
          '.bui-city-selector-index-list',
        );
        fireEvent.touchMove($codeContainer, {
          changedTouches: [
            {
              clientX: 350,
              clientY: 223,
            },
          ],
          cancelable: true,
          bubbles: true,
        });
        const citySText = screen.getByText('三门峡');
        expect(citySText).toBeVisible();
      });
    });

    it('render with citySelector special', async () => {
      const { container } = render(
        <CitySelector
          cities={[]}
          onSelect={onSelect}
          selectedCity={selectedCity}
          selectedCityGroupName={selectedCityGroupName}
          currentCity={currentCity}
          currentCityGroupName={currentCityGroupName}
          hotCities={hotCities}
          hotCitiesGroupName={hotCitiesGroupName}
          disableIndex
          title={title}
          onClose={onClose}
        />,
      );

      const $listContainer = queryEle(
        container,
        '.bui-city-selector-list-container',
      );
      expect($listContainer).toBe(null);

      const $codeContainer = queryEle(
        container,
        '.bui-city-selector-index-list',
      );
      expect($codeContainer).toBe(null);
    });
  });
});


================================================================================

组件: Collapse
文件: packages/bui-core/src/Collapse/__tests__/Collapse.test.tsx
========================================

import React from 'react';
import { render, screen } from 'testing';
import Collapse from '../Collapse';

describe('Collapse', () => {
  it('renders correctly', () => {
    render(
      <Collapse in timeout={1000}>
        <div>Collapse</div>
      </Collapse>,
    );
    expect(document.querySelector('.bui-collapse')).toHaveStyle(
      'transition: height 1000ms cubic-bezier(0.0, 0, 0.2, 1) 0ms',
    );
  });
  it.each(['horizontal', 'vertical'])(
    'collapse in from different direction',
    (direction) => {
      render(
        <Collapse in direction={direction as 'horizontal' | 'vertical'}>
          <div
            className="bui-collapse-content"
            style={{ height: '100px', width: '100px' }}
          >
            Collapse
          </div>
        </Collapse>,
      );
      const size = direction === 'horizontal' ? 'width' : 'height';
      const getSize = (_size) => {
        // eslint-disable-next-line no-underscore-dangle
        return screen.getByText('Collapse').style[_size];
      };
      expect(document.querySelector('.bui-collapse')).toHaveStyle(
        `${size}: fit-content`,
      );
      setTimeout(() => {
        expect(document.querySelector('.bui-collapse')).toHaveStyle(
          `${size}: ${getSize(size)}`,
        );
      }, 2000);
    },
  );
  it.each(['50px', 50])('render width collapsedSize correctly', (size) => {
    render(
      <Collapse in={false} collapsedSize={size}>
        <div>Collapse</div>
      </Collapse>,
    );
    expect(document.querySelector('.bui-collapse')).toHaveStyle('height: 50px');
  });

  it('render null when children is null', () => {
    render(<Collapse />);
    expect(document.querySelector('.bui-collapse')).toBeNull();
  });
});


================================================================================

组件: CollapsePanel
文件: packages/bui-core/src/CollapsePanel/__tests__/CollapsePanel.test.tsx
========================================

import React, { ReactElement, useState } from 'react';
import { render, isConformant, userEvent, screen, waitFor } from 'testing';
import CollapsePanel, { CollapsePanelItem, CollapsePanelProps } from '../index';

const setup = (props: CollapsePanelProps, children?: ReactElement) => {
  const component = render(
    <CollapsePanel {...props}>{children}</CollapsePanel>,
  );
  return {
    ...component,
  };
};

const setupByElement = (props: CollapsePanelProps, itemNum = 2) => {
  const component = render(
    <CollapsePanel {...props}>
      {itemNum
        ? Array(itemNum)
            .fill('')
            .map((item, index) => {
              return (
                <CollapsePanelItem
                  key={`${index + 1}`}
                  label={`这是面板标题${index + 1}`}
                >
                  这是面板内容{index + 1}
                </CollapsePanelItem>
              );
            })
        : null}
    </CollapsePanel>,
  );
  return {
    ...component,
  };
};

const items = [
  {
    key: '1',
    label: '这是面板标题1',
    children: <p>这是面板内容1</p>,
  },
  {
    key: '2',
    label: '这是面板标题2',
    children: <p>这是面板内容2</p>,
  },
];

describe('CollapsePanel', () => {
  isConformant({
    Component: CollapsePanel,
    displayName: 'BuiCollapsePanel',
    className: 'bui-collapse-panel',
    requiredProps: {
      items,
    },
  });
  it('should render children', () => {
    const { container } = setup({
      defaultActiveKeys: ['1'],
      items,
    });
    const firstPanel = container.querySelectorAll(
      '.bui-collapse-panel-item',
    )[0];
    expect(
      firstPanel.querySelector('.bui-collapse-panel-item-header-label'),
    ).toHaveTextContent('这是面板标题1');
    expect(
      firstPanel.querySelector('.bui-collapse-panel-item-content'),
    ).toHaveTextContent('这是面板内容1');
  });
  it('should default open active panel', () => {
    const { container } = setup({
      defaultActiveKeys: ['1'],
      items,
    });
    const firstPanel = container.querySelectorAll(
      '.bui-collapse-panel-item',
    )[0];
    const secondPanel = container.querySelectorAll(
      '.bui-collapse-panel-item',
    )[1];
    expect(firstPanel).toHaveClass('bui-collapse-panel-item-active');
    expect(secondPanel).not.toHaveClass('bui-collapse-panel-item-active');
  });
  it('should only open one panel when use accordion', async () => {
    const { container } = setup({
      defaultActiveKeys: ['1'],
      accordion: true,
      items,
    });
    const firstPanel = container.querySelectorAll(
      '.bui-collapse-panel-item',
    )[0];
    const secondPanel = container.querySelectorAll(
      '.bui-collapse-panel-item',
    )[1];

    userEvent.click(screen.getByText('这是面板标题2'));
    await waitFor(() => {
      expect(firstPanel).not.toHaveClass('bui-collapse-panel-item-active');
      expect(secondPanel).toHaveClass('bui-collapse-panel-item-active');
    });
  });
  it('should use custom icon', () => {
    const customIcon = <div>custom icon</div>;
    setup({
      defaultActiveKeys: ['1'],
      arrowIcon: customIcon,
      items: [
        {
          key: '1',
          label: '这是面板标题1',
          children: <p>这是面板内容1</p>,
        },
      ],
    });
    const icon = screen.getByText('custom icon');
    expect(icon).toBeVisible();
  });
  it('should use custom icon by function', async () => {
    setup({
      arrowIcon: (active) => {
        if (active) {
          return <div>active icon</div>;
        }
        return <div>unactived icon</div>;
      },
      items: [
        {
          key: '1',
          label: '这是面板标题1',
          children: <p>这是面板内容1</p>,
        },
      ],
    });
    const unactivedIcon = screen.getByText('unactived icon');
    expect(unactivedIcon).toBeVisible();
    userEvent.click(screen.getByText('这是面板标题1'));
    await waitFor(() => {
      const activeIcon = screen.getByText('active icon');
      expect(activeIcon).toBeVisible();
    });
  });
  it('should call onChange', async () => {
    const fakeChange = jest.fn();
    const Component = () => {
      const [activeKeys, setActiveKeys] = useState(['1']);
      const handleChange = (event, params) => {
        fakeChange(params.activeKeys);
        setActiveKeys(params.activeKeys);
      };

      return (
        <CollapsePanel
          activeKeys={activeKeys}
          items={items}
          onChange={handleChange}
        />
      );
    };
    const { container } = render(<Component />);
    const firstPanel = container.querySelectorAll(
      '.bui-collapse-panel-item',
    )[0];
    const secondPanel = container.querySelectorAll(
      '.bui-collapse-panel-item',
    )[1];

    userEvent.click(screen.getByText('这是面板标题2'));
    await waitFor(() => {
      expect(fakeChange).toBeCalled();
      expect(fakeChange).toBeCalledWith(['2', '1']);
      expect(firstPanel).toHaveClass('bui-collapse-panel-item-active');
      expect(secondPanel).toHaveClass('bui-collapse-panel-item-active');
    });
  });
  it('should return null', () => {
    const { container } = setup({});

    expect(container.firstChild).toBeNull();
  });

  describe('CollapsePanelItem', () => {
    it('should render children', () => {
      const { container } = setupByElement({
        defaultActiveKeys: ['1'],
      });
      const firstPanel = container.querySelectorAll(
        '.bui-collapse-panel-item',
      )[0];
      expect(
        firstPanel.querySelector('.bui-collapse-panel-item-header-label'),
      ).toHaveTextContent('这是面板标题1');
      expect(
        firstPanel.querySelector('.bui-collapse-panel-item-content'),
      ).toHaveTextContent('这是面板内容1');
    });
    it('should default open active panel', () => {
      const { container } = setupByElement({
        defaultActiveKeys: ['1'],
      });
      const firstPanel = container.querySelectorAll(
        '.bui-collapse-panel-item',
      )[0];
      const secondPanel = container.querySelectorAll(
        '.bui-collapse-panel-item',
      )[1];
      expect(firstPanel).toHaveClass('bui-collapse-panel-item-active');
      expect(secondPanel).not.toHaveClass('bui-collapse-panel-item-active');
    });
    it('should only open one panel when use accordion', async () => {
      const { container } = setupByElement({
        defaultActiveKeys: ['1'],
        accordion: true,
      });
      const firstPanel = container.querySelectorAll(
        '.bui-collapse-panel-item',
      )[0];
      const secondPanel = container.querySelectorAll(
        '.bui-collapse-panel-item',
      )[1];

      userEvent.click(screen.getByText('这是面板标题2'));
      await waitFor(() => {
        expect(firstPanel).not.toHaveClass('bui-collapse-panel-item-active');
        expect(secondPanel).toHaveClass('bui-collapse-panel-item-active');
      });
    });
    it('should use custom icon', () => {
      const customIcon = <div>custom icon</div>;

      setupByElement(
        {
          defaultActiveKeys: ['1'],
          accordion: true,
          arrowIcon: customIcon,
        },
        1,
      );
      const icon = screen.getByText('custom icon');
      expect(icon).toBeVisible();
    });
    it('should use custom icon by function', async () => {
      setupByElement(
        {
          arrowIcon: (active) => {
            if (active) {
              return <div>active icon</div>;
            }
            return <div>unactived icon</div>;
          },
        },
        1,
      );
      const unactivedIcon = screen.getByText('unactived icon');
      expect(unactivedIcon).toBeVisible();
      userEvent.click(screen.getByText('这是面板标题1'));
      await waitFor(() => {
        const activeIcon = screen.getByText('active icon');
        expect(activeIcon).toBeVisible();
      });
    });
    it('should call onChange', async () => {
      const fakeChange = jest.fn();
      const Component = () => {
        const [activeKeys, setActiveKeys] = useState(['1']);
        const handleChange = (event, params) => {
          fakeChange(params.activeKeys);
          setActiveKeys(params.activeKeys);
        };

        return (
          <CollapsePanel activeKeys={activeKeys} onChange={handleChange}>
            <CollapsePanelItem key="1" label="这是面板标题1">
              这是面板内容1
            </CollapsePanelItem>
            <CollapsePanelItem key="2" label="这是面板标题2">
              这是面板内容2
            </CollapsePanelItem>
          </CollapsePanel>
        );
      };
      const { container } = render(<Component />);
      const firstPanel = container.querySelectorAll(
        '.bui-collapse-panel-item',
      )[0];
      const secondPanel = container.querySelectorAll(
        '.bui-collapse-panel-item',
      )[1];

      userEvent.click(screen.getByText('这是面板标题2'));
      await waitFor(() => {
        expect(fakeChange).toBeCalled();
        expect(fakeChange).toBeCalledWith(['2', '1']);
        expect(firstPanel).toHaveClass('bui-collapse-panel-item-active');
        expect(secondPanel).toHaveClass('bui-collapse-panel-item-active');
      });
    });
    it('should return null', () => {
      const { container } = setupByElement({}, 0);

      expect(container.firstChild).toBeNull();
    });
  });
});


================================================================================

组件: Countdown
文件: packages/bui-core/src/Countdown/__tests__/Countdown.test.tsx
========================================

import React from 'react';
import { isConformant, render, act, screen } from 'testing';
import { Countdown } from '..';

jest.useFakeTimers();

describe('Countdown', () => {
  const rootClass = 'bui-countdown';

  isConformant({
    className: rootClass,
    displayName: 'BuiCountdown',
    Component: Countdown,
  });

  it('renders correctly with remainingTime prop', () => {
    render(<Countdown remainingTime={10 * 1000} format="HH:mm:ss" />);
    const zeroItems = screen.queryAllByText('0');
    const oneItems = screen.queryAllByText('1');
    expect(zeroItems).toHaveLength(5);
    expect(oneItems).toHaveLength(1);
  });

  it('renders correctly with endTimestamp prop', () => {
    render(
      <Countdown endTimestamp={Date.now() + 10 * 1000} format="HH:mm:ss" />,
    );
    const zeroItems = screen.queryAllByText('0');
    const oneItems = screen.queryAllByText('1');
    expect(zeroItems).toHaveLength(5);
    expect(oneItems).toHaveLength(1);
  });

  it('renders correctly with endTimestamp and serverTimestamp prop', () => {
    render(
      <Countdown
        endTimestamp={Date.now() + 10 * 1000}
        serverTimestamp={Date.now() - 10 * 1000}
        format="HH:mm:ss"
      />,
    );
    const zeroItems = screen.queryAllByText('0');
    const twoItems = screen.queryAllByText('2');
    expect(zeroItems).toHaveLength(5);
    expect(twoItems).toHaveLength(1);
  });

  it('renders countdown with format prop', () => {
    render(
      <Countdown
        endTimestamp={Date.now() + 100 * 365 * 24 * 60 * 60 * 1000}
        format="YYYY年MM月DD日HH时mm分ss秒SSS毫秒"
      />,
    );
    expect(screen.queryAllByText('年')).toHaveLength(1);
    expect(screen.queryAllByText('月')).toHaveLength(1);
    expect(screen.queryAllByText('日')).toHaveLength(1);
    expect(screen.queryAllByText('时')).toHaveLength(1);
    expect(screen.queryAllByText('分')).toHaveLength(1);
    expect(screen.queryAllByText('秒')).toHaveLength(1);
    expect(screen.queryAllByText('毫秒')).toHaveLength(1);
  });

  it('renders countdown with unitStyle prop', () => {
    render(
      <Countdown
        endTimestamp={Date.now() + 10 * 1000}
        unitStyle={{ color: 'rgb(255, 0, 0)' }}
        format="HH:mm:ss"
      />,
    );
    screen.queryAllByText(':').forEach((item) => {
      expect(item).toHaveStyle({
        color: 'rgb(255, 0, 0)',
      });
    });
  });

  it('renders countdown with valueStyle prop', () => {
    render(
      <Countdown
        endTimestamp={Date.now() + 15 * 1000}
        valueStyle={[{ fontSize: '15px' }, { fontSize: '20px' }]}
      />,
    );
    expect(screen.queryByText('1')).toHaveStyle({
      fontSize: '15px',
    });
    expect(screen.queryByText('5')).toHaveStyle({
      fontSize: '20px',
    });
  });

  it('renders countdown with timeSliceStyle prop', () => {
    const { container } = render(
      <Countdown
        endTimestamp={Date.now() + 10 * 1000}
        timeSliceStyle={{ backgroundColor: 'rgb(255, 0, 0)' }}
        format="HH:mm:ss"
      />,
    );
    const timeSlices = container.querySelectorAll(`.${rootClass}-slice`);
    timeSlices.forEach((item) => {
      expect(item).toHaveStyle({
        backgroundColor: 'rgb(255, 0, 0)',
      });
    });
  });

  it('onFinish prop has been trigger when countdown finished', () => {
    const fakeFinish = jest.fn();
    render(
      <Countdown endTimestamp={Date.now() + 10 * 1000} onFinish={fakeFinish} />,
    );
    act(() => {
      jest.advanceTimersByTime(10 * 1000);
    });
    expect(fakeFinish).toHaveBeenCalledTimes(1);
  });

  it('onChange prop has been trigger when countdown change', () => {
    const fakeChange = jest.fn();
    render(
      <Countdown endTimestamp={Date.now() + 10 * 1000} onChange={fakeChange} />,
    );
    act(() => {
      jest.advanceTimersByTime(1 * 1000);
    });
    expect(fakeChange).toBeCalled();
  });

  it('custom renders countdown with renderContent prop', () => {
    render(
      <Countdown
        endTimestamp={Date.now() + 15 * 1000}
        renderContent={(time) => {
          const { hours, minutes, seconds } = time;
          return (
            <div>
              <span>time</span> {`${hours}:${minutes}:${seconds}`}
            </div>
          );
        }}
      />,
    );
    expect(screen.queryByText('time')).toBeVisible();
  });
});


================================================================================

组件: Dialog
文件: packages/bui-core/src/Dialog/__tests__/Dialog.test.tsx
========================================

import React from 'react';
import { fireEvent, renderHook, waitFor } from '@testing-library/react';
import { Button } from '@bifrostui/react';
import { render, screen, act } from 'testing';
import Dialog from '../FunctionalDialog';
import '@testing-library/jest-dom/extend-expect';

describe('Dialog Functional Calls', () => {
  const rootClass = 'bui-dialog';
  let dialogHook;

  beforeEach(() => {
    document.body.innerHTML = '';
    jest.useFakeTimers();
    renderHook(() => {
      dialogHook = Dialog.useDialog();
    });
  });

  afterEach(() => {
    jest.clearAllTimers();
    jest.useRealTimers();
    jest.clearAllMocks();
  });

  it('The default type of dialog is confirm', async () => {
    const { getByTestId } = render(
      <Button
        data-testid="emit-button"
        onClick={() => {
          Dialog.prompt('Confirm title');
        }}
      >
        test
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button'));
    expect(
      document.body.querySelector(`.${rootClass}-body-desc`),
    ).toBeInTheDocument();
  });

  it('should resolve with true when Dialog.confirm is confirmed', async () => {
    let confirmPromise;
    const { getByTestId } = render(
      <Button
        data-testid="emit-button"
        onClick={() => {
          confirmPromise = Dialog.confirm({
            header: 'Confirm Title',
            message: 'Are you sure?',
            confirmText: 'Yes',
            cancelText: 'No',
          });
        }}
      >
        test
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button'));
    expect(screen.getByText('Confirm Title')).toBeInTheDocument();
    expect(screen.getByText('Are you sure?')).toBeInTheDocument();
    fireEvent.click(screen.getByText('Yes'));
    await waitFor(() => expect(confirmPromise).resolves.toBe(true));
  });

  it('should resolve with false when Dialog.confirm is cancelled', async () => {
    let confirmPromise;
    const { getByTestId } = render(
      <Button
        data-testid="emit-button"
        onClick={() => {
          confirmPromise = Dialog.confirm({
            header: 'Confirm Title',
            message: 'Are you sure?',
            confirmText: 'Yes',
            cancelText: 'Del',
          });
        }}
      >
        test
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button'));
    fireEvent.click(screen.getByText('Del'));
    await waitFor(() => expect(confirmPromise).resolves.toBe(false));
  });

  it('should resolve with the correct value when Dialog.prompt is confirmed', async () => {
    let promptPromise;
    const { getByTestId } = render(
      <Button
        data-testid="emit-button"
        onClick={() => {
          promptPromise = Dialog.prompt({
            header: 'Prompt Title',
            message: 'Please enter a value:',
            confirmText: 'Confirm',
            cancelText: 'Cancel',
          });
        }}
      >
        test
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button'));
    expect(
      document.body.querySelector(`.${rootClass}-body-title`),
    ).toBeInTheDocument();
    expect(
      document.body.querySelector(`.${rootClass}-body-input`),
    ).toBeInTheDocument();
    expect(screen.getByText('Prompt Title')).toBeInTheDocument();
    expect(screen.getByText('Please enter a value:')).toBeInTheDocument();

    const input = screen.getByPlaceholderText('请输入内容');
    fireEvent.change(input, { target: { value: 'Test Input' } });

    fireEvent.click(screen.getByText('Confirm'));
    await waitFor(() => expect(promptPromise).resolves.toBe('Test Input'));
    await act(async () => {
      await jest.runAllTimers();
    });
    expect(
      document.body.querySelector(`.${rootClass}`),
    ).not.toBeInTheDocument();
  });

  it('should resolve with false when Dialog.prompt is cancelled', async () => {
    let promptPromise;
    const { getByTestId } = render(
      <Button
        data-testid="emit-button"
        onClick={() => {
          promptPromise = Dialog.prompt({
            header: 'Prompt Title',
            message: 'Please enter a value:',
            confirmText: 'Confirm',
            cancelText: 'Delete',
          });
        }}
      >
        test
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button'));
    fireEvent.click(screen.getByText('Delete'));
    await waitFor(() => expect(promptPromise).resolves.toBe(false));
  });
  it('the default type of useDialog is confirm', async () => {
    const onConfirm = jest.fn();
    const onCancel = jest.fn();
    const { getByTestId } = render(
      <Button
        data-testid="emit-button"
        onClick={() => {
          dialogHook[0]({
            header: '标题',
            message: '描述内容',
            onConfirm,
            onCancel,
          });
        }}
      >
        test
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button'));
    expect(
      document.body.querySelector(`.${rootClass}-body-desc`),
    ).toBeInTheDocument();
    expect(screen.getByText('描述内容')).toBeInTheDocument();
    fireEvent.click(screen.getByText('取消'));
    await waitFor(async () => {
      expect(onCancel).toHaveBeenCalled();
      fireEvent.click(screen.getByText('确定'));
      await waitFor(() => {
        expect(onConfirm).toHaveBeenCalled();
      });
    });
  });

  it.each(['confirm', 'prompt'])(
    'should support basic api with useDialog',
    async (type) => {
      const dialog = dialogHook?.[0];
      const onConfirm = jest.fn();
      const onCancel = jest.fn();

      render(
        <Button
          onClick={() => {
            dialog[type]({
              message: `${type} message`,
              onConfirm,
              onCancel,
            });
          }}
        >
          dialog button
        </Button>,
      );
      fireEvent.click(screen.getByText('dialog button'));
      expect(screen.getByText(`${type} message`)).toBeInTheDocument();
      fireEvent.click(screen.getByText('取消'));
      await waitFor(async () => {
        expect(onCancel).toHaveBeenCalled();
        fireEvent.click(screen.getByText('确定'));
        await waitFor(() => {
          expect(onConfirm).toHaveBeenCalled();
        });
      });
    },
  );
});


================================================================================

组件: Divider
文件: packages/bui-core/src/Divider/__tests__/Divider.test.tsx
========================================

import React from 'react';
import { render, isConformant, screen } from 'testing';
import Divider from '../index';

const classPrefix = 'bui-divider';

describe('Divider', () => {
  isConformant({
    Component: Divider,
    displayName: 'BuiDivider',
    className: 'bui-divider',
  });
  describe('prop: direction', () => {
    it('should render default vertical currently', async () => {
      const { container } = render(<Divider />);
      const [divider] = [...container.getElementsByClassName(classPrefix)];
      // 测试渲染
      expect(divider).toHaveClass(`${classPrefix}-vertical`);
    });

    it('should render horizontal current', async () => {
      const { container } = render(<Divider direction="horizontal" />);
      const [divider] = [...container.getElementsByClassName(classPrefix)];
      // 测试渲染
      expect(divider).toHaveClass(`${classPrefix}-horizontal`);
    });
  });
  describe('prop: size', () => {
    it('size should be render current', () => {
      const { container } = render(<Divider size="32px" />);
      expect(container.firstChild).toHaveStyle('height: 32px');
    });
    it('size should be render current', () => {
      const { container } = render(
        <Divider direction="horizontal" size="32px" />,
      );
      expect(container.firstChild).toHaveStyle('width: 32px');
    });
  });
  it('should render children current', () => {
    const { container } = render(
      <Divider direction="horizontal">分割线</Divider>,
    );
    expect(container.querySelector('.bui-divider-line')).toBeTruthy();
    expect(screen.getByText('分割线')).toBeTruthy();
  });
});


================================================================================

组件: Drawer
文件: packages/bui-core/src/Drawer/__tests__/Drawer.test.tsx
========================================

import React from 'react';
import { act, isConformant, render, screen, userEvent, waitFor } from 'testing';
import Drawer from '../index';

describe('Drawer', () => {
  const rootClass = 'bui-drawer';
  beforeEach(() => {
    jest.useFakeTimers();
  });
  afterEach(() => {
    jest.clearAllTimers();
    jest.useRealTimers();
  });

  isConformant({
    Component: Drawer,
    displayName: 'BuiDrawer',
    className: rootClass,
    requiredProps: {
      open: true,
    },
    getTargetElement: () => {
      return document.querySelector('.bui-modal');
    },
  });
  it('renders correctly', async () => {
    const { container } = render(
      <Drawer open disablePortal>
        Drawer
      </Drawer>,
    );
    await act(async () => {
      await jest.runAllTimers();
    });
    expect(container.firstChild).toMatchSnapshot();
  });
  it('should open and close', async () => {
    const { rerender } = render(<Drawer>Drawer content</Drawer>);
    expect(screen.queryByText('Drawer content')).not.toBeInTheDocument();
    rerender(<Drawer open>Drawer content</Drawer>);
    expect(screen.getByText('Drawer content')).toBeInTheDocument();
  });

  it('should hide backdrop with hideBackdrop props', () => {
    render(
      <Drawer open hideBackdrop>
        Drawer content
      </Drawer>,
    );
    expect(document.querySelector('.bui-backdrop')).not.toBeInTheDocument();
  });

  it.each(['left', 'top', 'right', 'bottom'] as const)(
    'should render correctly with anchor props',
    (anchor) => {
      render(
        <Drawer open anchor={anchor}>
          Drawer
        </Drawer>,
      );
      expect(screen.getByText('Drawer')).toHaveClass(
        `${rootClass}-content-${anchor}`,
      );
    },
  );

  it('onclose should be called when closing drawer', () => {
    const onClose = jest.fn();
    render(
      <Drawer open onClose={onClose}>
        Drawer
      </Drawer>,
    );
    userEvent.click(screen.getByText('Drawer'));
    userEvent.click(document.querySelector('.bui-backdrop'));
    expect(onClose).toHaveBeenCalledTimes(1);
  });

  it('should delay the slide transition to complete using default theme values by default', async () => {
    render(<Drawer open>Drawer</Drawer>);
    await act(async () => {
      await jest.runAllTimers();
    });
    expect(screen.getByText('Drawer')).toHaveStyle({
      transition: 'transform 225ms cubic-bezier(0.0, 0, 0.2, 1) 0ms',
    });
  });

  it('after the slide transition exited the root dom can remove', async () => {
    const { rerender } = render(<Drawer open>Drawer</Drawer>);
    await act(async () => {
      await jest.runAllTimers();
    });
    rerender(<Drawer>Drawer</Drawer>);
    expect(screen.getByText('Drawer')).toBeInTheDocument();
    await act(async () => {
      await jest.runAllTimers();
    });
    await waitFor(() => {
      expect(screen.queryByText('Drawer')).not.toBeInTheDocument();
    });
  });

  it('should delay the slide transition to complete using custom theme values', async () => {
    render(
      <Drawer open transitionDuration={225}>
        Drawer
      </Drawer>,
    );
    await act(async () => {
      await jest.runAllTimers();
    });
    expect(screen.queryByText('Drawer')).toHaveStyle({
      transition: 'transform 225ms cubic-bezier(0.0, 0, 0.2, 1) 0ms',
    });
  });

  it('contentProps can set content element', () => {
    render(
      <Drawer open contentProps={{ className: 'test-content' }}>
        Drawer
      </Drawer>,
    );
    expect(screen.getByText('Drawer')).toHaveClass('test-content');
  });
});


================================================================================

组件: Fade
文件: packages/bui-core/src/Fade/__test__/Fade.test.tsx
========================================

import React from 'react';
import { render } from 'testing';
import Fade from '../Fade';

describe('Fade', () => {
  it('renders correctly', () => {
    const { queryByTestId } = render(
      <Fade in appear={false} timeout={1500}>
        <div data-testid="fade-test">fade test</div>
      </Fade>,
    );
    expect(queryByTestId('fade-test').style.opacity).toEqual('1');
  });
  it('can hide when not in', () => {
    const { queryByTestId } = render(
      <Fade in={false} timeout={1500}>
        <div data-testid="fade-test">fade test</div>
      </Fade>,
    );
    expect(queryByTestId('fade-test').style.transition).not.toMatch(
      'opacity 1500ms cubic-bezier(0.4, 0, 0.2, 1) 0ms',
    );
    expect(queryByTestId('fade-test').style.opacity).toEqual('0');
    expect(queryByTestId('fade-test').style.visibility).toEqual('hidden');
  });
  it('can fade instantly if appear', () => {
    const { queryByTestId } = render(
      <Fade in={false} appear timeout={1500}>
        <div data-testid="fade-test">fade test</div>
      </Fade>,
    );
    expect(queryByTestId('fade-test').style.transition).not.toMatch(
      'opacity 1500ms cubic-bezier(0.4, 0, 0.2, 1) 0ms',
    );
    expect(queryByTestId('fade-test').style.opacity).toEqual('0');
    expect(queryByTestId('fade-test').style.visibility).toEqual('hidden');
  });
});


================================================================================

组件: IconButton
文件: packages/bui-core/src/IconButton/__tests__/IconButton.test.tsx
========================================

import React from 'react';
import { isConformant, render, screen, userEvent } from 'testing';
import IconButton from '../index';

describe('IconButton', () => {
  const rootClass = 'bui-icon-btn';

  isConformant({
    Component: IconButton,
    displayName: 'BuiIconButton',
    className: rootClass,
  });

  it('can trigger a function by being clicked', () => {
    const onClick = jest.fn();
    render(<IconButton onClick={onClick}>IconButton</IconButton>);
    userEvent.click(screen.getByRole('button'));
    expect(onClick).toHaveBeenCalled();
  });

  it('should render correctly with size props', () => {
    const colors = ['small', 'medium', 'large'] as const;
    colors.forEach((size) => {
      render(<IconButton size={size}>{size} IconButton</IconButton>);
      expect(
        screen.getByRole('button', { name: `${size} IconButton` }),
      ).toHaveClass(`${rootClass}-${size}`);
    });
  });

  it('should render correctly with variant props', () => {
    const colors = ['default', 'contained', 'outlined'] as const;
    colors.forEach((variant) => {
      render(<IconButton variant={variant}>{variant} IconButton</IconButton>);
      expect(
        screen.getByRole('button', { name: `${variant} IconButton` }),
      ).toHaveClass(`${rootClass}-${variant}`);
    });
  });
  it('should render correctly with color props', () => {
    const colors = [
      'primary',
      'warning',
      'success',
      'info',
      'danger',
      'default',
    ] as const;
    colors.forEach((color) => {
      render(<IconButton color={color}>{color} IconButton</IconButton>);
      expect(
        screen.getByRole('button', { name: `${color} IconButton` }),
      ).toHaveClass(`${rootClass}-${color}`);
    });
  });
  it('in miniapp children can set color props', async () => {
    jest.resetModules();
    jest.doMock('@bifrostui/utils', () => ({
      isMini: true,
    }));
    const { default: MiniIconButton } = await import('../index');
    render(
      <MiniIconButton color="success">
        <div>icon</div>
      </MiniIconButton>,
    );
    expect(screen.getByText('icon')).toHaveAttribute('color', 'success');
    const mockBackdropFn = jest.fn();
    const TestChildren = (props) => {
      mockBackdropFn(props);
      return <div />;
    };
    render(
      <MiniIconButton color="success" variant="contained">
        <TestChildren />
      </MiniIconButton>,
    );
    expect(mockBackdropFn).toHaveBeenCalledWith(
      expect.objectContaining({ htmlColor: '#fff' }),
    );
  });
});


================================================================================

组件: Image
文件: packages/bui-core/src/Image/__tests__/Image.test.tsx
========================================

import React from 'react';
import { fireEvent, render, screen, userEvent } from 'testing';
import { waitFor } from '@testing-library/react';
import Image from '../index';

describe('Image', () => {
  const classPrefix = 'bui-image';
  const src =
    'https://gw.alicdn.com/i2/O1CN01D7yqW229UZMB5eh00_!!6000000008071-0-alipicbeacon.jpg_960x960Q90s100.jpg_.webp';
  it('renders correctly', async () => {
    const { container } = render(
      <Image src={src} fit="contain" width={100} height={100} />,
    );
    const [wrapper] = [...container.getElementsByClassName(classPrefix)];
    const image = screen.getByRole('img');
    fireEvent.load(screen.getByRole('img'));
    await waitFor(() => {
      expect(wrapper).toContainElement(image);
      expect(image).toHaveAttribute('src', src);
    });
  });
  it('can enable placeholder', async () => {
    const { container } = render(
      <Image src={src} fit="contain" width={100} height={100} placeholder />,
    );
    expect(
      container.querySelector(`.${classPrefix}-default-icon-item`),
    ).not.toBeNull();
  });

  it.each(['contain', 'cover', 'fill', 'none', 'scale-down'])(
    'renders with different fit modes',
    async (
      fit:
        | 'contain'
        | 'cover'
        | 'fill'
        | 'none'
        | 'scale-down'
        | 'widthFix'
        | 'heightFix',
    ) => {
      render(<Image src={src} fit={fit} width={100} height={100} />);
      expect(screen.getByRole('img').style.objectFit === fit);
    },
  );

  it('has placeholder', async () => {
    const placeholder = <div data-testid="test-placeholder" />;
    render(
      <Image
        src="https://not.exists.image/"
        fit="contain"
        width={100}
        height={100}
        placeholder={placeholder}
      />,
    );

    expect(screen.getByTestId('test-placeholder'));
  });
  it('should call onLoad callback', async () => {
    const onLoad = jest.fn();
    render(
      <Image
        src={src}
        fit="contain"
        width={100}
        height={100}
        onLoad={onLoad}
      />,
    );
    fireEvent.load(screen.getByRole('img'));
    expect(onLoad).toHaveBeenCalled();
  });
  it('should call onError callback', async () => {
    const onLoad = jest.fn();
    render(
      <Image
        src={src}
        fit="contain"
        width={100}
        height={100}
        onError={onLoad}
      />,
    );
    fireEvent.error(screen.getByRole('img'));
    expect(onLoad).toHaveBeenCalled();
  });
  it('should call onClick', async () => {
    const onLoad = jest.fn();
    render(
      <Image
        src={src}
        fit="contain"
        width={100}
        height={100}
        onClick={onLoad}
      />,
    );
    userEvent.click(screen.getByRole('img'));
    expect(onLoad).toHaveBeenCalled();
  });
  it('supports vanilla lazyload', async () => {
    global.HTMLImageElement.prototype.loading = 'eager';
    render(<Image src={src} fit="contain" width={100} height={100} lazy />);
    expect(screen.getByRole('img')).toHaveAttribute('loading', 'lazy');
  });
});


================================================================================

组件: Input
文件: packages/bui-core/src/Input/__tests__/Input.test.tsx
========================================

import React from 'react';
import {
  act,
  fireEvent,
  isConformant,
  render,
  screen,
  userEvent,
} from 'testing';
import { Input } from '..';

describe('Input', () => {
  const rootClass = 'bui-input';

  isConformant({
    className: rootClass,
    displayName: 'BuiInput',
    Component: Input,
  });

  it('should show clear button when input has value and focus', () => {
    const { container } = render(<Input value="clear" clearable />);
    userEvent.click(screen.getByRole('textbox'));
    const clearBtn = container.querySelector(`.${rootClass}-clear`);
    expect(clearBtn).toBeVisible();
  });

  describe('Input Ref Event', () => {
    it('should bind clear,focus and blur event', () => {
      const ref = React.createRef<HTMLInputElement>();
      render(<Input value="123" inputRef={ref} />);
      expect(ref.current).toHaveProperty('focus');
      expect(ref.current).toHaveProperty('blur');
    });

    it('should focus when call ref focus event', () => {
      const ref = React.createRef<HTMLInputElement>();
      render(<Input inputRef={ref} />);
      act(() => {
        const input = screen.getByRole('textbox');
        ref.current.focus();
        expect(input).toHaveFocus();
      });
    });

    it('should blur when call ref blur event', () => {
      const ref = React.createRef<HTMLInputElement>();
      render(<Input inputRef={ref} />);
      act(() => {
        const input = screen.getByRole('textbox');
        ref.current.focus();
        expect(input).toHaveFocus();
        ref.current.blur();
        expect(input).not.toHaveFocus();
      });
    });
  });

  it('should render start icon', () => {
    const startIcon = <div className="test-start-icon">startIcon</div>;
    const { container } = render(<Input startIcon={startIcon} />);
    const inputWrapper = container.querySelector(`.${rootClass}`);
    const icon = screen.getByText('startIcon');
    expect(icon.innerHTML).toBe('startIcon');
    expect(inputWrapper).toMatchSnapshot();
  });

  it('should render end icon', () => {
    const endIcon = <div className="test-end-icon">endIcon</div>;
    const { container } = render(<Input endIcon={endIcon} />);
    const inputWrapper = container.querySelector(`.${rootClass}`);
    const icon = screen.getByText('endIcon');
    expect(icon.innerHTML).toBe('endIcon');
    expect(inputWrapper).toMatchSnapshot();
  });

  it('should render placeholder', () => {
    render(<Input placeholder="请输入内容" />);
    const inputWrapper = screen.getByPlaceholderText('请输入内容');
    expect(inputWrapper).toMatchSnapshot();
  });

  it('should disabled', () => {
    render(<Input disabled />);
    act(() => {
      const input = screen.getByRole('textbox');
      userEvent.click(input);
      expect(input).not.toHaveFocus();
    });
  });

  it('should clear input after `onClear` event has been called', () => {
    const fakeClear = jest.fn();
    const { container } = render(
      <Input defaultValue="123" clearable onClear={fakeClear} />,
    );
    const input: HTMLInputElement = screen.getByRole('textbox');
    userEvent.click(input);
    const clearBtn = container.querySelector(`.${rootClass}-clear`);
    fireEvent.click(clearBtn);
    expect(fakeClear).toHaveBeenCalled();
    expect(input.value).toBe('');
  });

  it('`onChange` event should be called when input value change', () => {
    const fakeChange = jest.fn();
    render(<Input onChange={fakeChange} defaultValue="" />);
    const input = screen.getByRole('textbox');
    userEvent.type(input, '1234');
    expect(fakeChange).toHaveBeenCalled();
    expect(input).toHaveValue('1234');
  });

  describe('miniapp Input', () => {
    const originalModule = jest.requireActual('@bifrostui/utils');
    const restApi = jest.requireActual('react');
    it('`onChange` event should be called when input value change', async () => {
      jest.spyOn(console, 'error').mockImplementation();
      jest.resetModules();
      jest.doMock('@bifrostui/utils', () => ({
        ...originalModule,
        isMini: true,
      }));
      jest.doMock('react', () => ({
        ...restApi,
      }));
      const { default: MiniInput } = await import('../index');
      const fakeChange = jest.fn();
      render(<MiniInput onChange={fakeChange} defaultValue="" />);
      const input = screen.getByRole('textbox');
      userEvent.type(input, '1234');
      expect(fakeChange).toHaveBeenCalled();
      expect(input).toHaveValue('1234');
    });
  });
});


================================================================================

组件: List
文件: packages/bui-core/src/List/__tests__/List.test.tsx
========================================

import React from 'react';
import { CloseIcon } from '@bifrostui/icons';
import { render, isConformant, screen, userEvent } from 'testing';
import List, { ListItem, ListProps, ListItemContent } from '../index';

const setup = (props: ListProps) => {
  const component = render(<List {...props} />);
  return {
    ...component,
  };
};

describe('List', () => {
  isConformant({
    Component: List,
    displayName: 'BuiList',
    className: 'bui-list',
  });
  describe('prop: size', () => {
    it.each(['small', 'medium', 'large'] as const)(
      'should render size correct',
      (size) => {
        const { container } = render(
          <List size={size}>
            <ListItem>1</ListItem>
            <ListItem>2</ListItem>
            <ListItem>3</ListItem>
          </List>,
        );
        expect(container.firstChild).toHaveClass(`bui-list-${size}`);
      },
    );
  });
  it('list should render litItem current', () => {
    const { container } = setup({
      header: '列表标题',
      subheader: '列表子标题',
      children: null,
    });
    expect(container).toHaveTextContent('列表标题');
    expect(container).toHaveTextContent('列表子标题');
  });
  it('list should render divider default', () => {
    const { container } = render(
      <List>
        <ListItem />
        <ListItem />
      </List>,
    );
    const divider = container.getElementsByClassName('bui-list-item-divider');
    expect(divider.length).toBe(2);
  });
});

describe('ListItem', () => {
  describe('prop: endIcon', () => {
    it('listItem should render endIcon', () => {
      const { container } = render(
        <List>
          <ListItem endIcon={<CloseIcon />} />
        </List>,
      );
      const element = container.getElementsByClassName('bui-svg-icon');
      expect(element.length).toBe(1);
      // expect(element).toContainElement(closeIcon);
      // expect(element).not.toContainElement(arrowForwardIcon);
    });
    it('should not render endIcon when it is false', () => {
      const { container } = render(
        <List>
          <ListItem endIcon={false} />
        </List>,
      );
      const arrowForward = container.getElementsByClassName('bui-svg-icon');
      expect(arrowForward.length).toBe(0);
    });
    it('should render endIcon default', () => {
      const { container } = render(
        <List>
          <ListItem
            onClick={() => {
              console.log('test');
            }}
          >
            test
          </ListItem>
        </List>,
      );
      const element = container.getElementsByClassName('bui-svg-icon');
      expect(element.length).toBe(1);
      // expect(container.getElementsByClassName('bui-svg-icon')?.[0]).toContainElement(
      //   arrowForwardIcon,
      // );
    });
  });
  describe('prop: disabled', () => {
    it('could click default', () => {
      const onClick = jest.fn();
      render(
        <List>
          <ListItem onClick={onClick}>list-item</ListItem>
        </List>,
      );

      userEvent.click(screen.getByText(/list-item/));
      expect(onClick).toHaveBeenCalled();
    });
    it('could not click when it is disabled', () => {
      const onClick = jest.fn(() => {
        console.log('成功点击List');
      });
      const { container } = render(
        <List>
          <ListItem disabled onClick={onClick}>
            点击列表
          </ListItem>
        </List>,
      );
      expect(container.firstChild.childNodes[0]).toHaveClass(
        'bui-list-item-disabled',
      );
    });
  });
});

describe('ListContent', () => {
  it('listContent should render content', () => {
    const { container } = setup({
      children: (
        <ListItem>
          <ListItemContent primary="主要内容" secondary="次要内容" />
        </ListItem>
      ),
    });
    expect(container).toHaveTextContent('主要内容');
    expect(container).toHaveTextContent('次要内容');
  });
});


================================================================================

组件: Loading
文件: packages/bui-core/src/Loading/__tests__/Loading.test.tsx
========================================

import React from 'react';
import { render, screen, isConformant } from 'testing';
import Loading from '../index';

describe('Loading', () => {
  const rootClass = 'bui-loading';

  isConformant({
    Component: Loading,
    displayName: 'BuiLoading',
    className: rootClass,
  });

  it('default render have bui-loading-vertical classname', async () => {
    render(<Loading data-testid={rootClass} />);
    expect(screen.getByTestId(rootClass)).toHaveClass('bui-loading');
    expect(screen.getByTestId(rootClass)).toHaveClass('bui-loading-vertical');
  });

  it('text chilren render have wrapper', async () => {
    render(<Loading data-testid={rootClass}>加载中...</Loading>);
    expect(screen.getByText('加载中...')).toHaveClass('bui-loading-text');
    expect(screen.getByTestId(rootClass)).toContainElement(
      screen.getByText('加载中...'),
    );
  });

  it('horizontal render correctly', async () => {
    render(<Loading data-testid={rootClass} direction="horizontal" />);
    expect(screen.getByTestId(rootClass)).not.toHaveClass(
      'bui-loading-vertical',
    );
    expect(screen.getByTestId(rootClass)).toHaveClass('bui-loading-horizontal');
  });
});


================================================================================

组件: Modal
文件: packages/bui-core/src/Modal/__test__/Modal.test.tsx
========================================

import React from 'react';
import { render, screen } from 'testing';
import Modal from '../Modal';

const mockBackdropFn = jest.fn();
// eslint-disable-next-line react/display-name
jest.mock('../../Backdrop', () => (props: any) => {
  mockBackdropFn(props);
  const { children, onClick } = props;
  return (
    <div data-testid="backdrop-mock" onClick={onClick}>
      {children}
    </div>
  );
});

const mockPortalFn = jest.fn();
jest.mock('../../Portal', () =>
  // eslint-disable-next-line react/display-name
  React.forwardRef((props: any, ref: any) => {
    mockPortalFn(props);
    return <div ref={ref}>{props.children}</div>;
  }),
);

describe('Modal', () => {
  it('should render content when open', () => {
    const { getByText } = render(
      <Modal open className="demo-modal">
        <div className="content">content</div>
      </Modal>,
    );
    expect(getByText('content')).toHaveTextContent('content');
  });
  it('should not render when closed', () => {
    const { queryByTestId } = render(
      <Modal open={false} className="demo-modal">
        <div className="content" data-testid="test-modal-content">
          content
        </div>
      </Modal>,
    );
    expect(queryByTestId('test-modal-content')).toBeNull();
  });
  it('should be able to hide BackDrop', () => {
    const { queryByTestId } = render(
      <Modal open className="demo-modal" hideBackdrop>
        <div className="content" data-testid="test-modal-content">
          content
        </div>
      </Modal>,
    );
    expect(queryByTestId('backdrop-mock')).toBeNull();
  });
  it('should pass props to BackDrop', () => {
    render(
      <Modal open BackdropProps={{ invisible: true }}>
        <div className="content" data-testid="test-modal-content">
          content
        </div>
      </Modal>,
    );
    expect(mockBackdropFn).toHaveBeenCalledWith(
      expect.objectContaining({ invisible: true }),
    );
  });
  it('should be able to disable portal', () => {
    render(
      <Modal open disablePortal>
        <div className="content" data-testid="test-modal-content">
          content
        </div>
      </Modal>,
    );
    expect(mockPortalFn).toHaveBeenCalledWith(
      expect.objectContaining({ disablePortal: true }),
    );
  });
  it('should call onClose when backdrop clicked', () => {
    const closefn = jest.fn();
    render(
      <Modal open onClose={closefn}>
        <div className="content" data-testid="test-modal-content">
          content
        </div>
      </Modal>,
    );
    screen.getByTestId('backdrop-mock').click();
    expect(closefn).toHaveBeenCalled();
  });
});


================================================================================

组件: NavBar
文件: packages/bui-core/src/NavBar/__tests__/NavBar.test.tsx
========================================

import React from 'react';
import { render, screen, isConformant } from 'testing';
import NavBar from '../index';

jest.mock('@bifrostui/utils', () => {
  const originalModule = jest.requireActual('@bifrostui/utils');
  return {
    ...originalModule,
    useSize: jest.fn(() => ({ width: '100%', height: 45 })),
  };
});

describe('Loading', () => {
  const rootClass = 'bui-navbar';

  isConformant({
    Component: NavBar,
    displayName: 'BuiNavBar',
    className: rootClass,
  });

  it('title props', async () => {
    render(<NavBar title="标题" />);
    expect(screen.getByText('标题')).toBeInTheDocument();
  });

  it('left props', async () => {
    render(<NavBar left="返回" />);
    expect(screen.getByText('返回')).toBeInTheDocument();
  });

  it('left props', async () => {
    render(<NavBar leftIcon={<div>mockicon</div>} />);
    expect(screen.getByText('mockicon')).toBeInTheDocument();
  });

  it('right props', async () => {
    render(<NavBar right="文案" />);
    expect(screen.getByText('文案')).toBeInTheDocument();
  });

  it('The fixed attribute causes a classname', async () => {
    render(<NavBar data-testid={rootClass} fixed />);
    expect(screen.getByTestId(rootClass)).toHaveClass('bui-navbar-fixed');
  });

  it('The placeholder attribute causes a block', async () => {
    const { container } = render(
      <NavBar data-testid={rootClass} fixed placeholder />,
    );

    const elements = container.getElementsByClassName(
      `${rootClass}-placeholder`,
    );
    expect(elements.length).toBe(1);
  });
});


================================================================================

组件: Picker
文件: packages/bui-core/src/Picker/__tests__/Picker.test.tsx
========================================

import React from 'react';
import {
  act,
  fireEvent,
  isConformant,
  render,
  screen,
  userEvent,
} from 'testing';
import Picker from '..';

describe('Picker', () => {
  const rootClass = 'bui-picker';
  const singleData = [
    [
      {
        value: 1,
        label: '周一',
      },
      {
        value: 2,
        label: '周二',
      },
      {
        value: 3,
        label: '周三',
      },
      {
        value: 4,
        label: '周四',
      },
      {
        value: 5,
        label: '周五',
      },
      {
        value: 6,
        label: '周六',
      },
      {
        value: 7,
        label: '周日',
      },
    ],
  ];
  const multiData = [
    [
      {
        value: 1,
        label: '周一',
      },
      {
        value: 2,
        label: '周二',
      },
      {
        value: 3,
        label: '周三',
      },
      {
        value: 4,
        label: '周四',
      },
      {
        value: 5,
        label: '周五',
      },
      {
        value: 6,
        label: '周六',
      },
      {
        value: 7,
        label: '周日',
      },
    ],
    [
      {
        value: 1,
        label: '上午',
      },
      {
        value: 2,
        label: '中午',
      },
      {
        value: 3,
        label: '下午',
      },
    ],
  ];
  const cascadeData = [
    {
      value: 1,
      label: '北京',
      children: [
        {
          value: 1,
          label: '朝阳区',
          children: [
            {
              value: 1,
              label: '朝阳街',
            },
          ],
        },
        {
          value: 2,
          label: '海淀区',
        },
        {
          value: 3,
          label: '大兴区',
        },
        {
          value: 4,
          label: '东城区',
        },
        {
          value: 5,
          label: '西城区',
        },
        {
          value: 6,
          label: '丰台区',
        },
      ],
    },
    {
      value: 2,
      label: '上海',
      children: [
        {
          value: 1,
          label: '黄埔区',
        },
        {
          value: 2,
          label: '长宁区',
        },
        {
          value: 3,
          label: '普陀区',
        },
        {
          value: 4,
          label: '杨浦区',
        },
        {
          value: 5,
          label: '浦东新区',
        },
        {
          value: 6,
          label: '徐汇区',
          children: [
            {
              value: 1,
              label: '龙耀路',
            },
            {
              value: 2,
              label: '云锦路',
            },
          ],
        },
      ],
    },
  ];

  const cascadeCallbackOptions = [
    [
      {
        value: 1,
        label: '北京',
        children: [
          {
            value: 1,
            label: '朝阳区',
            children: [{ value: 1, label: '朝阳街' }],
          },
          { value: 2, label: '海淀区' },
          { value: 3, label: '大兴区' },
          { value: 4, label: '东城区' },
          { value: 5, label: '西城区' },
          { value: 6, label: '丰台区' },
        ],
      },
      {
        value: 2,
        label: '上海',
        children: [
          { value: 1, label: '黄埔区' },
          { value: 2, label: '长宁区' },
          { value: 3, label: '普陀区' },
          { value: 4, label: '杨浦区' },
          { value: 5, label: '浦东新区' },
          {
            value: 6,
            label: '徐汇区',
            children: [
              { value: 1, label: '龙耀路' },
              { value: 2, label: '云锦路' },
            ],
          },
        ],
      },
    ],
    [
      { value: 1, label: '朝阳区', children: [{ value: 1, label: '朝阳街' }] },
      { value: 2, label: '海淀区' },
      { value: 3, label: '大兴区' },
      { value: 4, label: '东城区' },
      { value: 5, label: '西城区' },
      { value: 6, label: '丰台区' },
    ],
    [{ value: 1, label: '朝阳街' }],
  ];

  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.clearAllTimers();
    jest.useRealTimers();
    jest.clearAllMocks();
  });

  isConformant({
    className: rootClass,
    displayName: 'BuiPicker',
    Component: Picker,
    requiredProps: {
      open: true,
    },
    getTargetElement: () => {
      return document.querySelector(`.${rootClass}`);
    },
  });

  it('should open when `open` Props is true', () => {
    render(<Picker open options={singleData} />);
    expect(screen.queryAllByText('周一').length).toBe(1);
  });

  it('should no error', () => {
    render(<Picker open />);
    expect(
      document.querySelector(`.${rootClass}-container`).childNodes.length,
    ).toBe(0);
  });

  it('should render title', () => {
    render(<Picker open title="请选择" options={singleData} />);
    expect(screen.queryAllByText('请选择').length).toBe(1);
  });

  it('should render one column', () => {
    render(<Picker open options={singleData} />);
    const panels = document.querySelectorAll(`.${rootClass}-panel`);
    expect(panels.length).toBe(1);
  });

  it('should render two columns', () => {
    render(<Picker open options={multiData} />);
    const panels = document.querySelectorAll(`.${rootClass}-panel`);
    expect(panels.length).toBe(2);
  });

  it('should render three columns', () => {
    render(<Picker open options={cascadeData} />);
    const panels = document.querySelectorAll(`.${rootClass}-panel`);
    expect(panels.length).toBe(3);
  });

  it('should default select options with `value` props', () => {
    render(<Picker open options={cascadeData} value={[2, 6, 2]} />);
    const [roller1, roller2, roller3] = document.querySelectorAll(
      `.${rootClass}-panel-roller`,
    );
    expect(roller1).toHaveStyle('transform: rotate3d(1, 0, 0, 40deg)');
    expect(roller2).toHaveStyle('transform: rotate3d(1, 0, 0, 120deg)');
    expect(roller3).toHaveStyle('transform: rotate3d(1, 0, 0, 40deg)');
  });

  it('should render props in content dom with `contentProps`', () => {
    render(
      <Picker
        open
        options={cascadeData}
        contentProps={{ style: { height: '300px' } }}
      />,
    );
    const content = document.querySelector(`.${rootClass}-content`);
    expect(content).toHaveStyle('height: 300px');
  });

  it('should call `onConfirm` when click confirm button', () => {
    const confirm = jest.fn((_, { value }) => value);
    render(
      <Picker
        open
        onConfirm={confirm}
        value={[2, 6, 2]}
        options={cascadeData}
      />,
    );
    const comfirmButton = document.querySelector(`.${rootClass}-confirm`);
    userEvent.click(comfirmButton);
    expect(confirm).toHaveBeenCalled();
    expect(confirm).toReturnWith([2, 6, 2]);
  });

  it('should modify callback `value` when click confirm button', () => {
    const confirm = jest.fn((_, { options, value }) => {
      return { options, value };
    });
    const close = jest.fn((_, { options, value }) => {
      return { options, value };
    });
    render(
      <Picker
        open
        onConfirm={confirm}
        onClose={close}
        value={[1, 100]}
        options={cascadeData}
      />,
    );
    const comfirmButton = document.querySelector(`.${rootClass}-confirm`);
    userEvent.click(comfirmButton);
    expect(confirm).toHaveBeenCalled();
    expect(confirm).toReturnWith({
      options: cascadeCallbackOptions,
      value: [1, 1, 1],
    });
    expect(close).toReturnWith({
      options: cascadeCallbackOptions,
      value: [1, 1, 1],
    });
  });

  it('should modify callback `value` when click cancel button', () => {
    const close = jest.fn((_, { options, value }) => {
      return { options, value };
    });
    render(
      <Picker open onClose={close} value={[2, 6, 100]} options={cascadeData} />,
    );
    const cancelButton = document.querySelector(`.${rootClass}-cancel`);
    userEvent.click(cancelButton);
    expect(close).toReturnWith({
      options: [
        [
          {
            value: 1,
            label: '北京',
            children: [
              {
                value: 1,
                label: '朝阳区',
                children: [{ value: 1, label: '朝阳街' }],
              },
              { value: 2, label: '海淀区' },
              { value: 3, label: '大兴区' },
              { value: 4, label: '东城区' },
              { value: 5, label: '西城区' },
              { value: 6, label: '丰台区' },
            ],
          },
          {
            value: 2,
            label: '上海',
            children: [
              { value: 1, label: '黄埔区' },
              { value: 2, label: '长宁区' },
              { value: 3, label: '普陀区' },
              { value: 4, label: '杨浦区' },
              { value: 5, label: '浦东新区' },
              {
                value: 6,
                label: '徐汇区',
                children: [
                  { value: 1, label: '龙耀路' },
                  { value: 2, label: '云锦路' },
                ],
              },
            ],
          },
        ],
        [
          { value: 1, label: '黄埔区' },
          { value: 2, label: '长宁区' },
          { value: 3, label: '普陀区' },
          { value: 4, label: '杨浦区' },
          { value: 5, label: '浦东新区' },
          {
            value: 6,
            label: '徐汇区',
            children: [
              { value: 1, label: '龙耀路' },
              { value: 2, label: '云锦路' },
            ],
          },
        ],
        [
          { value: 1, label: '龙耀路' },
          { value: 2, label: '云锦路' },
        ],
      ],
      value: [2, 6, 1],
    });
  });

  it('should modify callback `value` when click confirm button in multiple picker', () => {
    const confirm = jest.fn((_, { options, value }) => {
      return { options, value };
    });
    const close = jest.fn((_, { options, value }) => {
      return { options, value };
    });
    render(
      <Picker
        open
        onConfirm={confirm}
        onClose={close}
        value={[100, 100]}
        options={multiData}
      />,
    );
    const comfirmButton = document.querySelector(`.${rootClass}-confirm`);
    userEvent.click(comfirmButton);
    expect(confirm).toHaveBeenCalled();
    expect(confirm).toReturnWith({
      options: multiData,
      value: [1, 1],
    });
    expect(close).toReturnWith({
      options: multiData,
      value: [1, 1],
    });
  });

  it('should modify callback `value` when click confirm button in single picker', () => {
    const confirm = jest.fn((_, { options, value }) => {
      return { options, value };
    });
    const close = jest.fn((_, { options, value }) => {
      return { options, value };
    });
    render(
      <Picker
        open
        onConfirm={confirm}
        onClose={close}
        value={[100]}
        options={singleData}
      />,
    );
    const comfirmButton = document.querySelector(`.${rootClass}-confirm`);
    userEvent.click(comfirmButton);
    expect(confirm).toHaveBeenCalled();
    expect(confirm).toReturnWith({
      options: singleData,
      value: [1],
    });
    expect(close).toReturnWith({
      options: singleData,
      value: [1],
    });
  });

  it('should call cascade `onOptionChange` when select option', async () => {
    const change = jest.fn((_, { value }) => value);
    render(<Picker open onOptionChange={change} options={cascadeData} />);

    await act(async () => {
      await jest.runAllTimers();
    });

    const [panel1] = document.querySelectorAll(`.${rootClass}-panel`);
    const [roller1] = document.querySelectorAll(`.${rootClass}-panel-roller`);
    fireEvent.touchStart(panel1, {
      touches: [
        {
          clientX: 0,
          clientY: 0,
        },
      ],
      cancelable: true,
      bubbles: true,
    });
    fireEvent.touchMove(panel1, {
      touches: [
        {
          clientX: 0,
          clientY: -36,
        },
      ],
      cancelable: true,
      bubbles: true,
    });
    fireEvent.transitionEnd(roller1);

    expect(change).toBeCalled();
    expect(change).toReturnWith([2, 1]);
  });

  it('should call multiple `onOptionChange` when select option', async () => {
    const change = jest.fn((_, { value }) => value);
    render(<Picker open onOptionChange={change} options={multiData} />);

    await act(async () => {
      await jest.runAllTimers();
    });

    const [, panel2] = document.querySelectorAll(`.${rootClass}-panel`);
    const [, roller2] = document.querySelectorAll(`.${rootClass}-panel-roller`);
    fireEvent.touchStart(panel2, {
      touches: [
        {
          clientX: 0,
          clientY: 0,
        },
      ],
      cancelable: true,
      bubbles: true,
    });
    fireEvent.touchMove(panel2, {
      touches: [
        {
          clientX: 0,
          clientY: -36,
        },
      ],
      cancelable: true,
      bubbles: true,
    });
    fireEvent.transitionEnd(roller2);

    expect(change).toBeCalled();
    expect(change).toReturnWith([1, 2]);
  });

  it('should roll with inertial', async () => {
    const change = jest.fn((_, { value }) => value);
    render(<Picker open onOptionChange={change} options={multiData} />);

    await act(async () => {
      await jest.runAllTimers();
    });

    const [, panel2] = document.querySelectorAll(`.${rootClass}-panel`);
    const [, roller2] = document.querySelectorAll(`.${rootClass}-panel-roller`);
    fireEvent.touchStart(panel2, {
      touches: [
        {
          clientX: 0,
          clientY: 0,
        },
      ],
      cancelable: true,
      bubbles: true,
    });
    fireEvent.touchMove(panel2, {
      touches: [
        {
          clientX: 0,
          clientY: -36,
        },
      ],
      cancelable: true,
      bubbles: true,
    });
    // 惯性滚动
    fireEvent.touchEnd(panel2, {
      touches: [
        {
          clientX: 0,
          clientY: -30,
        },
      ],
      cancelable: true,
      bubbles: true,
    });
    fireEvent.transitionEnd(roller2);

    expect(change).toBeCalled();
    expect(change).toReturnWith([1, 3]);
  });

  it('should call `onCancel` when click cancel button', () => {
    const cancel = jest.fn();
    render(<Picker open onCancel={cancel} options={cascadeData} />);
    userEvent.click(document.querySelector(`.${rootClass}-cancel`));
    expect(cancel).toBeCalled();
  });

  it('should call `onClose` when Picker hidden', () => {
    const close = jest.fn();
    render(<Picker open onClose={close} options={cascadeData} />);
    userEvent.click(document.querySelector(`.${rootClass}-cancel`));
    expect(close).toBeCalled();
    userEvent.click(document.querySelector(`.${rootClass}-confirm`));
    expect(close).toBeCalled();
    userEvent.click(document.querySelector('.bui-backdrop'));
    expect(close).toBeCalled();
  });
});


================================================================================

组件: Popover
文件: packages/bui-core/src/Popover/__tests__/Popover.test.tsx
========================================

import React from 'react';
import { isConformant, render, screen, userEvent, fireEvent } from 'testing';
import Popover from '../index';

const directions = [
  'top',
  'left',
  'right',
  'bottom',
  'topLeft',
  'topRight',
  'bottomLeft',
  'bottomRight',
  'leftTop',
  'leftBottom',
  'rightTop',
  'rightBottom',
];

describe('Popover', () => {
  const rootClass = 'bui-popover';

  isConformant({
    Component: Popover,
    displayName: 'BuiPopover',
    className: rootClass,
    skip: [
      'component-has-root-ref',
      'component-handles-classNames',
      'component-has-default-className',
      'component-handles-style',
    ],
  });
  it('test content defaultOpen props', () => {
    render(
      <Popover
        title="This is a popover title"
        content="This is a popover content"
        defaultOpen
      >
        <div>children</div>
      </Popover>,
    );
    expect(screen.getByText('This is a popover title')).toBeInTheDocument();
    expect(screen.getByText('This is a popover content')).toBeInTheDocument();
  });

  it('test hideArrow props', () => {
    render(
      <Popover title="This is a popover title" hideArrow defaultOpen>
        <div>children</div>
      </Popover>,
    );
    expect(
      document.querySelector('.bui-popover-arrow'),
    ).not.toBeInTheDocument();
  });

  it('test open onOpenChange props', () => {
    const onOpenChange = jest.fn();
    render(
      <Popover title="This is a popover2" open>
        <div data-testid="popoverTestid">children</div>
      </Popover>,
    );
    expect(screen.getByText('This is a popover2')).toBeInTheDocument();

    const $childrenDom = screen.getByTestId('popoverTestid');
    userEvent.click($childrenDom);
    expect(onOpenChange).toHaveBeenCalledTimes(0);
  });

  directions.forEach((placement) => {
    it(`test placement props the ${placement}`, () => {
      render(
        // @ts-ignore
        <Popover title="This is a popover3" defaultOpen placement={placement}>
          <div>children</div>
        </Popover>,
      );
      const direction = placement.split(/[A-Z]/)[0];
      const $dom = document.querySelector('.bui-popover');
      expect($dom).toHaveClass(`popover-${direction}`);
    });
  });

  it('test trigger onOpenChange props', () => {
    const onOpenChange = jest.fn();
    render(
      <Popover
        title="This is a popover4"
        defaultOpen
        trigger={['click', 'hover']}
        onOpenChange={onOpenChange}
      >
        <div data-testid="popoverTestid">children</div>
      </Popover>,
    );
    const $childrenDom = screen.getByTestId('popoverTestid');
    userEvent.click($childrenDom);
    expect(onOpenChange).toHaveBeenCalled();
  });

  it('test trigger click anywhere hide props', () => {
    const onOpenChange = jest.fn();
    render(
      <Popover
        title="This is a popover4"
        defaultOpen
        trigger="click"
        onOpenChange={onOpenChange}
      >
        <div data-testid="popoverTestid">children</div>
      </Popover>,
    );
    userEvent.click(document.body);
    expect(onOpenChange).toHaveBeenCalled();
  });

  it('test trigger hover onOpenChange props', () => {
    const onOpenChange = jest.fn();
    render(
      <Popover
        title="This is a popover4"
        defaultOpen
        trigger={['hover']}
        onOpenChange={onOpenChange}
      >
        <div data-testid="popoverTestid">children</div>
      </Popover>,
    );
    const $childrenDom = screen.getByTestId('popoverTestid');
    fireEvent.mouseEnter($childrenDom);
    fireEvent.mouseLeave($childrenDom);
    expect(onOpenChange).toBeCalledTimes(2);

    // 代表不触发隐藏
    userEvent.click(document.body);
    expect(onOpenChange).toBeCalledTimes(2);
  });
});


================================================================================

组件: Portal
文件: packages/bui-core/src/Portal/__tests__/Portal.test.tsx
========================================

import React from 'react';
import { render, screen } from 'testing';
import Portal from '../index';

describe('Portal', () => {
  it('should have access to the mountNode', () => {
    const ref = React.createRef<HTMLDivElement>();
    const { unmount } = render(
      <Portal ref={ref}>
        <div>hello</div>
      </Portal>,
    );
    expect(ref.current).toEqual(document.body);
    unmount();
    expect(ref.current).toEqual(null);
  });

  it('should have access to the mountNode when disabledPortal equal true', () => {
    const ref = React.createRef<HTMLDivElement>();
    const { unmount, rerender } = render(
      <Portal ref={ref} disablePortal>
        <div data-testid="mountNode">hello</div>
      </Portal>,
    );
    expect(ref.current).toEqual(screen.getByTestId('mountNode'));
    rerender(
      <Portal ref={ref}>
        <div data-testid="mountNode">hello</div>
      </Portal>,
    );
    expect(ref.current).toEqual(document.body);
    unmount();
    expect(ref.current).toEqual(null);
  });

  it('should render in a different node', () => {
    render(
      <div data-testid="root">
        <h1 data-testid="Hello">Hello</h1>
        <Portal>
          <h1 data-testid="World">World</h1>
        </Portal>
      </div>,
    );
    const rootElement = screen.getByTestId('root');
    expect(rootElement.contains(screen.getByTestId('Hello'))).toEqual(true);
    expect(rootElement.contains(screen.getByTestId('World'))).toEqual(false);
  });

  it('should change container on prop change', () => {
    const containerRef = React.createRef<HTMLDivElement>();
    const { rerender } = render(
      <span>
        <strong ref={containerRef} />
        <Portal container={() => containerRef.current} disablePortal>
          <div data-testid="test" />
        </Portal>
      </span>,
    );
    expect(screen.getByTestId('test').parentElement.tagName).toEqual('SPAN');

    rerender(
      <span>
        <strong ref={containerRef} />
        <Portal container={() => containerRef.current}>
          <div data-testid="test" />
        </Portal>
      </span>,
    );
    expect(screen.getByTestId('test').parentElement.tagName).toEqual('STRONG');

    rerender(
      <span>
        <strong ref={containerRef} />
        <Portal>
          <div data-testid="test" />
        </Portal>
      </span>,
    );
    expect(screen.getByTestId('test').parentElement.tagName).toEqual('BODY');
  });

  it('container will have the portal children appended to it', () => {
    const containerRef = React.createRef<HTMLDivElement>();
    render(
      <>
        <div ref={containerRef} data-testid="container" />
        <Portal container={() => containerRef.current}>
          <div data-testid="test" />
        </Portal>
      </>,
    );
    expect(
      screen.getByTestId('container').contains(screen.getByTestId('test')),
    ).toEqual(true);
  });

  it('test onRootElementMouted props', () => {
    const onRootElementMouted = jest.fn();
    const containerRef = React.createRef<HTMLDivElement>();
    render(
      <>
        <div ref={containerRef} data-testid="container" />
        <Portal
          container={() => containerRef.current}
          onRootElementMouted={onRootElementMouted}
        >
          <div data-testid="test" />
        </Portal>
      </>,
    );
    expect(onRootElementMouted).toHaveBeenCalled();
  });
});


================================================================================

组件: Progress
文件: packages/bui-core/src/Progress/__tests__/Progress.test.tsx
========================================

import React from 'react';
import { isConformant, render, screen, userEvent } from 'testing';
import Progress from '../index';
import { handleGradient } from '../Progress';

describe('Progress', () => {
  const rootClass = 'bui-progress';

  isConformant({
    Component: Progress,
    displayName: 'BuiProgress',
    className: rootClass,
  });

  it('renders correctly', () => {
    render(
      <Progress percent={54} strokeColor="#582331" data-testid="progress" />,
    );
    expect(screen.getByTestId('progress')).toMatchSnapshot();
  });

  it('should render correctly with percent props', () => {
    const P1 = render(<Progress percent={55} />);
    const P2 = render(<Progress percent={101} />);
    expect(P1.container.querySelector('.bui-progress-bg')).toHaveStyle({
      width: '55%',
    });
    expect(P2.container.querySelector('.bui-progress-bg')).toHaveStyle({
      width: '100%',
    });
  });

  it('can customize the color of the progress bar', () => {
    const { container } = render(<Progress percent={55} strokeColor="red" />);
    expect(container.querySelector('.bui-progress-bg')).toHaveStyle({
      background: 'red',
    });
  });

  it('can customize the color of the progress bar as gradient', () => {
    expect(
      handleGradient({
        from: 'red',
        to: 'blue',
        direction: 'to right',
        '0%': 'green',
        '50%': 'yellow',
        '100%': 'purple',
      }).backgroundImage,
    ).toBe('linear-gradient(to right, green 0%, yellow 50%, purple 100%)');
    expect(
      handleGradient({ '0%': '#108ee9', '100%': '#87d068' }).backgroundImage,
    ).toBe('linear-gradient(to right, #108ee9 0%, #87d068 100%)');
    expect(
      handleGradient({ from: 'red', to: 'blue', direction: 'to right' })
        .backgroundImage,
    ).toBe('linear-gradient(to right, red, blue)');
  });

  it('can customize the width of the progress bar', () => {
    const { container } = render(<Progress percent={55} strokeWidth={15} />);
    expect(container.querySelector('.bui-progress-bg')).toHaveStyle({
      height: '15px',
    });
  });

  it('can trigger a function by being clicked', () => {
    const onClick = jest.fn();
    render(<Progress percent={55} data-testid="progress" onClick={onClick} />);
    userEvent.click(screen.getByTestId('progress'));
    expect(onClick).toHaveBeenCalled();
  });
});


================================================================================

组件: Radio
文件: packages/bui-core/src/Radio/__tests__/Radio.test.tsx
========================================

import React, { useState } from 'react';
import { act, fireEvent, isConformant, render, screen } from 'testing';
import { Radio, RadioGroup } from '..';

describe('Radio', () => {
  const rootClass = 'bui-radio';

  isConformant({
    className: rootClass,
    displayName: 'BuiRadio',
    Component: Radio,
  });

  it('should be checked', () => {
    const onChange = jest.fn();
    render(
      <Radio checked onChange={onChange}>
        淘票票
      </Radio>,
    );
    const radio = screen.getByRole<HTMLInputElement>('radio');
    expect(radio.checked).toBeTruthy();
  });

  it('should have value', () => {
    render(<Radio value="淘票票" />);
    const radio = screen.getByRole<HTMLInputElement>('radio');
    expect(radio.value).toBe('淘票票');
  });

  it('should have name property', () => {
    render(<Radio name="radio">Radio</Radio>);
    const radio = screen.getByRole<HTMLInputElement>('radio');
    expect(radio.name).toBe('radio');
  });

  it('should be disabled', () => {
    render(<Radio disabled data-testid="radio" />);
    expect(screen.getByTestId('radio')).toHaveClass(`${rootClass}-disabled`);
    expect(screen.getByRole('radio')).toHaveAttribute('disabled');
  });

  it('should use custom unchecked icon', () => {
    const uncheckedIcon = <div className="test-unchecked-icon">icon</div>;
    render(<Radio icon={uncheckedIcon} />);
    const icon = screen.getByText('icon');
    expect(icon).toBeVisible();
  });

  it('should use custom checked icon', () => {
    const onChange = jest.fn();
    const checkedIcon = <div className="test-checked-icon">icon</div>;
    render(<Radio checkedIcon={checkedIcon} checked onChange={onChange} />);
    const icon = screen.getByText('icon');
    expect(icon).toBeVisible();
  });

  describe('Radio label placement', () => {
    const labelPlacements = ['top', 'bottom', 'left', 'right'] as const;
    labelPlacements.forEach((placement) => {
      it(`label should on the ${placement}`, () => {
        const { getByTestId } = render(
          <Radio data-testid={rootClass} labelPlacement={placement}>
            淘票票
          </Radio>,
        );
        const radio = getByTestId(rootClass);
        expect(radio).toMatchSnapshot();
      });
    });
  });

  it('should call `onChange`', () => {
    const fakeChange = jest.fn((e, data) => data.checked);
    const { container } = render(
      <Radio value="淘票票" onChange={fakeChange}>
        淘票票
      </Radio>,
    );
    act(() => {
      const radio = container.querySelector(`.${rootClass}-input`);
      fireEvent.click(radio);
      expect(fakeChange).toReturnWith(true);
    });
  });

  describe('RadioGroup', () => {
    it('value should be controled by `value` property', () => {
      function RadioComponent() {
        const [value] = useState('淘票票');
        return (
          <RadioGroup value={value}>
            <Radio value="水门桥">水门桥</Radio>
            <Radio value="淘票票">淘票票</Radio>
            <Radio value="喜洋洋">喜洋洋</Radio>
          </RadioGroup>
        );
      }

      const { container } = render(<RadioComponent />);
      const radioList = container.querySelectorAll<HTMLInputElement>(
        `.${rootClass}-input`,
      );
      expect(radioList[0].checked).toBeFalsy();
      expect(radioList[1].checked).toBeTruthy();
    });

    it('should call `onChange`', () => {
      const fakeChange = jest.fn((e, data) => data.value);
      const { container } = render(
        <RadioGroup onChange={fakeChange}>
          <Radio value="水门桥">水门桥</Radio>
          <Radio value="淘票票">淘票票</Radio>
          <Radio value="喜洋洋">喜洋洋</Radio>
        </RadioGroup>,
      );
      const radioList = container.querySelectorAll(`.${rootClass}-input`);
      fireEvent.click(radioList[1]);
      expect(fakeChange).toReturnWith('淘票票');
    });

    it('should disabled', () => {
      const { container } = render(
        <RadioGroup disabled>
          <Radio value="水门桥">水门桥</Radio>
          <Radio value="淘票票">淘票票</Radio>
          <Radio value="喜洋洋">喜洋洋</Radio>
        </RadioGroup>,
      );
      const radioList = container.querySelectorAll<HTMLInputElement>(
        `.${rootClass}-input`,
      );
      radioList.forEach((item) => {
        expect(item.disabled).toBeTruthy();
      });
    });
  });

  describe('miniapp Radio', () => {
    const originalModule = jest.requireActual('@bifrostui/utils');
    const restApi = jest.requireActual('react');
    it('should call `onChange`', async () => {
      jest.resetModules();
      jest.doMock('@bifrostui/utils', () => ({
        ...originalModule,
        isMini: true,
      }));
      jest.doMock('react', () => ({
        ...restApi,
      }));
      const { default: MiniRadio } = await import('../index');
      const fakeChange = jest.fn((e, data) => data.checked);
      const { container } = render(
        <MiniRadio value="淘票票" onChange={fakeChange}>
          淘票票
        </MiniRadio>,
      );
      const radio = container.querySelector(`.${rootClass}-input`);
      fireEvent.click(radio);
      expect(fakeChange).toReturnWith(true);
    });
  });
});


================================================================================

组件: Rating
文件: packages/bui-core/src/Rating/__tests__/Rating.test.tsx
========================================

import React from 'react';
import { isConformant, render, screen, userEvent } from 'testing';
import Rating from '../index';

describe('Rating', () => {
  const rootClass = 'bui-rating';

  isConformant({
    Component: Rating,
    displayName: 'BuiRating',
    className: rootClass,
  });
  it('renders correctly', () => {
    const { container } = render(<Rating />);
    expect(container).toMatchSnapshot();
  });
  it('medium size is default', () => {
    const { container } = render(<Rating />);
    expect(
      container.querySelectorAll(`.${rootClass}-container-medium`).length,
    ).toBe(5);
  });
  it.each(['large', 'medium', 'small', 'xsmall'] as const)(
    'should render correctly with size props',
    (size) => {
      const { container } = render(<Rating size={size} />);
      expect(
        container.querySelectorAll(`.${rootClass}-container-${size}`).length,
      ).toBe(5);
    },
  );

  it('should round the value to the provided precision', () => {
    const { container } = render(<Rating value={3.9} />);
    expect(container.querySelectorAll(`.${rootClass}-item-active`).length).toBe(
      3,
    );
  });

  it('the count of icons can be customized', () => {
    render(<Rating count={8} />);
    expect(screen.queryAllByRole('radio').length).toBe(8);
  });
  it('allow to render half', () => {
    const { container } = render(<Rating value={4.6} allowHalf />);
    expect(container.querySelectorAll(`.${rootClass}-item-half`).length).toBe(
      5,
    );
    expect(container.querySelectorAll(`.${rootClass}-item-active`).length).toBe(
      9,
    );
  });

  it('disabled rating can not respond to events', () => {
    const { container } = render(<Rating defaultValue={3} disabled />);
    userEvent.click(container.querySelectorAll('.bui-rating-item')[2]);
    expect(container.querySelectorAll(`.${rootClass}-item-active`).length).toBe(
      3,
    );
    expect(container.querySelector(`.${rootClass}`)).toHaveClass(
      `${rootClass}-disabled`,
    );
  });

  it('read only not clickable', () => {
    const handleChange = jest.fn();
    const { container } = render(<Rating readOnly onChange={handleChange} />);
    userEvent.click(container.querySelector(`.${rootClass}-item-readonly`));
    expect(handleChange).not.toBeCalled();
  });

  it('character can be customized', () => {
    render(<Rating checkedIcon="A" icon="B" defaultValue={3} />);
    expect(screen.getAllByText('A').length).toBe(3);
    expect(screen.getAllByText('B').length).toBe(2);
  });

  // it.each(['primary', 'warning', 'success', 'info', 'danger', 'vip'] as const)(
  //   'should render correctly with color props',
  //   (color) => {
  //     const { container } = render(<Rating color={color} value={4} />);
  //     expect(
  //       container.querySelectorAll(`.${rootClass}-item-${color}`).length,
  //     ).toBe(4);
  //   },
  // );

  it('should fire change event when click rate item', () => {
    const handleChange = jest.fn();
    const { container } = render(<Rating onChange={handleChange} />);
    expect(container.querySelectorAll(`.${rootClass}-item-active`).length).toBe(
      0,
    );
    userEvent.click(container.querySelector(`.${rootClass}-item`));
    expect(container.querySelectorAll(`.${rootClass}-item-active`).length).toBe(
      1,
    );
    expect(handleChange).toBeCalled();
  });

  it('click again to clear active status', () => {
    const { container } = render(<Rating />);
    userEvent.click(container.querySelector(`.${rootClass}-item`));
    expect(container.querySelectorAll(`.${rootClass}-item-active`).length).toBe(
      1,
    );
    userEvent.click(container.querySelector(`.${rootClass}-item`));
    expect(container.querySelectorAll(`.${rootClass}-item-active`).length).toBe(
      0,
    );
  });

  it('click again to can not clear active status', () => {
    const { container } = render(<Rating disableClear />);
    userEvent.click(container.querySelector(`.${rootClass}-item`));
    expect(container.querySelectorAll(`.${rootClass}-item-active`).length).toBe(
      1,
    );
    userEvent.click(container.querySelector(`.${rootClass}-item`));
    expect(container.querySelectorAll(`.${rootClass}-item-active`).length).toBe(
      1,
    );
  });
});


================================================================================

组件: ScrollView
文件: packages/bui-core/src/ScrollView/__test__/ScrollView.test.tsx
========================================

import React, { useEffect, useState } from 'react';
import { act, render, screen } from 'testing';
import { fireEvent, waitFor } from '@testing-library/react';
import ScrollView from '../ScrollView';

describe('ScrollView', () => {
  const rootClass = 'bui-scroll';

  it('renders correctly', () => {
    const { container } = render(
      <ScrollView scrollY>
        <div className="item" data-testid="item">
          test item
        </div>
      </ScrollView>,
    );
    expect(
      container.querySelector(`.${rootClass}-view-scroll-y`),
    ).not.toBeNull();
    expect(screen.getByTestId('item')).not.toBeNull();
  });
  it('can scrollX', () => {
    const { container } = render(
      <ScrollView scrollX>
        <div className="item" data-testid="item">
          test item
        </div>
      </ScrollView>,
    );
    expect(
      container.querySelector(`.${rootClass}-view-scroll-x`),
    ).not.toBeNull();
  });

  it('will trigger scrolling events and apply thresholds', () => {
    const originalOffsetHeight = Object.getOwnPropertyDescriptor(
      HTMLElement.prototype,
      'offsetHeight',
    );
    Object.defineProperty(HTMLElement.prototype, 'offsetHeight', {
      configurable: true,
      value: 1000,
    });
    Object.defineProperty(HTMLElement.prototype, 'scrollHeight', {
      configurable: true,
      value: 2000,
    });

    const onScrollToUpper = jest.fn();
    const onScrollToLower = jest.fn();
    const onScroll = jest.fn();
    const { container } = render(
      <ScrollView
        scrollY
        style={{ height: '1000px' }}
        upperThreshold={300}
        lowerThreshold={300}
        {...{ onScrollToUpper, onScrollToLower, onScroll }}
      >
        <div className="item" data-testid="item" style={{ height: '2000px' }}>
          test item
        </div>
      </ScrollView>,
    );
    expect(onScrollToUpper).not.toHaveBeenCalled();
    expect(onScrollToLower).not.toHaveBeenCalled();
    expect(onScroll).not.toHaveBeenCalled();
    act(() => {
      fireEvent.scroll(container.querySelector(`.${rootClass}`), {
        target: { scrollTop: 800 },
      });
    });
    expect(onScrollToUpper).not.toHaveBeenCalled();
    expect(onScrollToLower).toHaveBeenCalled();
    expect(onScroll).toHaveBeenCalledTimes(1);

    act(() => {
      fireEvent.scroll(container.querySelector(`.${rootClass}`), {
        target: { scrollTop: 500 },
      });
    });
    expect(onScrollToUpper).not.toHaveBeenCalled();
    expect(onScroll).toHaveBeenCalledTimes(2);

    act(() => {
      fireEvent.scroll(container.querySelector(`.${rootClass}`), {
        target: { scrollTop: 200 },
      });
    });
    expect(onScrollToUpper).toHaveBeenCalled();
    expect(onScroll).toHaveBeenCalledTimes(3);

    Object.defineProperty(
      HTMLElement.prototype,
      'offsetHeight',
      originalOffsetHeight,
    );
  });
  it('can scroll into view', async () => {
    const originalOffsetHeight = Object.getOwnPropertyDescriptor(
      HTMLElement.prototype,
      'offsetHeight',
    );
    Object.defineProperty(HTMLElement.prototype, 'offsetTop', {
      configurable: true,
      value: 2000,
    });
    const App = () => {
      const [scrollIntoView, setScrollIntoView] = useState<
        string | undefined
      >();
      useEffect(() => {
        setScrollIntoView('item1');
      });
      return (
        <ScrollView
          scrollY
          style={{ height: '1000px' }}
          scrollIntoView={scrollIntoView}
          scrollIntoViewAlignment="start"
        >
          <div
            className="item"
            data-testid="item"
            id="item"
            style={{ height: '2000px' }}
          >
            test item
          </div>
          <div
            className="item1"
            data-testid="item1"
            id="item1"
            style={{ height: '2000px' }}
          >
            test item1
          </div>
        </ScrollView>
      );
    };
    const { container } = render(<App />);
    await act(async () =>
      waitFor(() => {
        expect(container.querySelector(`.${rootClass}`).scrollTop).toEqual(
          2000,
        );
      }),
    );

    Object.defineProperty(
      HTMLElement.prototype,
      'offsetHeight',
      originalOffsetHeight,
    );
  });
  it('can scroll to scrollTop/scrollLeft', async () => {
    window.HTMLElement.prototype.scrollIntoView = jest.fn();
    // eslint-disable-next-line react/prop-types
    const App = ({ x = false, isAnimated = false, isInit = false }) => {
      const [scrollTop, setScrollTop] = useState(isInit ? 3000 : 0);
      useEffect(() => {
        setTimeout(() => setScrollTop(3000), 10);
      });
      return (
        <ScrollView
          scrollY={!x}
          scrollX={x}
          style={{ height: '1000px', width: '1000px' }}
          scrollTop={x ? undefined : scrollTop}
          scrollLeft={!x ? undefined : scrollTop}
          scrollWithAnimation={isAnimated}
        >
          <div
            className="item"
            data-testid="item"
            id="item"
            style={{ height: '2000px', width: '2000px' }}
          >
            test item
          </div>
          <div
            className="item1"
            data-testid="item1"
            id="item1"
            style={{ height: '2000px', width: '2000px' }}
          >
            test item1
          </div>
        </ScrollView>
      );
    };
    const doTest = async (isAnimated, x, isInit) => {
      const { container } = render(
        <App isAnimated={isAnimated} x={x} isInit={isInit} />,
      );
      await waitFor(() => {
        expect(
          container.querySelector(`.${rootClass}`)[
            x ? 'scrollLeft' : 'scrollTop'
          ],
        ).toEqual(3000);
      });
    };
    await Promise.all([
      doTest(false, false, false),
      doTest(true, false, false),
      doTest(false, true, false),
      doTest(true, true, false),
      doTest(false, false, true),
      doTest(true, false, true),
      doTest(false, true, true),
      doTest(true, true, true),
    ]);
  });
});


================================================================================

组件: Select
文件: packages/bui-core/src/Select/__tests__/Select.test.tsx
========================================

import React from 'react';
import { act, render, screen, userEvent, isConformant } from 'testing';
import Select from '../Select';
import SelectOption from '../SelectOption';

const classPrefix = 'bui-select';

describe('Select', () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });
  isConformant({
    Component: Select,
    displayName: 'BuiSelect',
    className: 'bui-select',
  });
  it('should render default value current', () => {
    render(
      <Select defaultValue={2}>
        <SelectOption value={1}>option1</SelectOption>
        <SelectOption value={2}>option2</SelectOption>
      </Select>,
    );

    expect(screen.getByText(/option2/)).toHaveClass('bui-select-option-active');
  });
  it('should render value current', () => {
    render(
      <Select defaultValue={1} value={2}>
        <SelectOption value={1}>option1</SelectOption>
        <SelectOption value={2}>option2</SelectOption>
      </Select>,
    );
    expect(screen.getByText(/option2/)).toHaveClass('bui-select-option-active');
  });
  it('should render icon current', () => {
    render(
      <Select icon={<div>open</div>}>
        <SelectOption value={1}>option1</SelectOption>
        <SelectOption value={2}>option2</SelectOption>
      </Select>,
    );
    expect(screen.getByText(/open/)).toBeTruthy();
  });

  it('renders base', () => {
    const { container } = render(
      <Select>
        <SelectOption value={1}>option1</SelectOption>
        <SelectOption value={2}>option2</SelectOption>
      </Select>,
    );
    expect(container.firstChild).toHaveClass(`${classPrefix}`);
  });

  it('renders with disabled', () => {
    const { container } = render(
      <Select disabled>
        <SelectOption value={1}>option1</SelectOption>
        <SelectOption value={2}>option2</SelectOption>
      </Select>,
    );
    expect(container.firstChild).toHaveClass(`${classPrefix}-disabled`);
  });
  describe('action', () => {
    it('should call onClose when click close', async () => {
      const onClose = jest.fn();
      render(
        <Select onClose={onClose} open>
          <SelectOption value={1}>option1</SelectOption>
          <SelectOption value={2}>option2</SelectOption>
        </Select>,
      );
      await act(async () => {
        await userEvent.click(document.querySelector('.bui-select'));
      });
      expect(onClose).toHaveBeenCalled();
    });
    it('should call onOpen when click open', async () => {
      const onOpen = jest.fn();
      render(
        <Select onOpen={onOpen} open={false}>
          <SelectOption value={1}>option1</SelectOption>
          <SelectOption value={2}>option2</SelectOption>
        </Select>,
      );
      await act(async () => {
        userEvent.click(document.querySelector('.bui-select'));
      });
      await act(async () => {
        await jest.runAllTimers();
      });
      expect(onOpen).toHaveBeenCalled();
    });
    it('should call onClick when click open', async () => {
      const onClick = jest.fn();
      render(
        <Select onClick={onClick} open={false}>
          <SelectOption value={1}>option1</SelectOption>
          <SelectOption value={2}>option2</SelectOption>
        </Select>,
      );
      await act(async () => {
        userEvent.click(document.querySelector('.bui-select'));
      });
      expect(onClick).toHaveBeenCalled();
    });
    it('should not select option when it is disabled', async () => {
      const onClick = jest.fn((e, value) => value);
      render(
        <Select onChange={onClick}>
          <SelectOption disabled value={1}>
            option1
          </SelectOption>
          <SelectOption value={2}>option2</SelectOption>
        </Select>,
      );
      expect(screen.getByText(/option1/)).toHaveClass(
        'bui-select-option-disabled',
      );
      await act(async () => {
        userEvent.click(screen.getByText(/option1/));
      });
      expect(onClick).not.toHaveBeenCalled();
    });
    it('should not select  when it is disabled', async () => {
      const onClick = jest.fn();
      const { container } = render(
        <Select disabled onClick={onClick}>
          <SelectOption disabled value={1}>
            option1
          </SelectOption>
          <SelectOption value={2}>option2</SelectOption>
        </Select>,
      );
      expect(container.firstChild).toHaveClass('bui-select-disabled');
      await act(async () => {
        userEvent.click(screen.getByText(/option1/));
      });
      expect(onClick).not.toHaveBeenCalled();
    });
    it('should pass value as part of the event.target of select', () => {
      const onSelect = jest.fn((e, value) => value);
      render(
        <Select onChange={onSelect}>
          <SelectOption value="option1">option1</SelectOption>
          <SelectOption data-testid="option2" value="option2">
            option2
          </SelectOption>
        </Select>,
      );
      userEvent.click(screen.getByText(/option2/));

      expect(onSelect).toReturnWith({ value: 'option2' });
    });
  });
});


================================================================================

组件: Skeleton
文件: packages/bui-core/src/Skeleton/__tests__/Skeleton.test.tsx
========================================

import React from 'react';
import { render, isConformant, screen } from 'testing';
import Skeleton from '../index';

describe('Skeleton', () => {
  const rootClass = 'bui-skeleton';

  isConformant({
    Component: Skeleton,
    displayName: 'BuiSkeleton',
    className: rootClass,
  });
  it('should render with children', () => {
    render(<Skeleton>Skeleton</Skeleton>);
    expect(screen.getByText('Skeleton')).toHaveClass(
      `${rootClass}-animation-wave`,
    );
    expect(screen.getByText('Skeleton')).toHaveClass(
      `${rootClass}-with-children`,
    );
  });

  it.each(['wave', 'pulse'] as const)(
    'should render correctly with animation props',
    (animation) => {
      render(<Skeleton animation={animation}>Skeleton</Skeleton>);
      expect(screen.getByText('Skeleton')).toHaveClass(
        `${rootClass}-animation-${animation}`,
      );
    },
  );

  it('when animation is false not has animation class', () => {
    render(<Skeleton animation={false}>Skeleton</Skeleton>);
    expect(screen.getByText('Skeleton').getAttribute('class')).not.toMatch(
      /bui-skeleton-animation-/gi,
    );
  });
  it.each(['text', 'circular', 'rectangular', 'rounded'] as const)(
    'should render correctly with variant props',
    (variant) => {
      render(<Skeleton variant={variant}>Skeleton</Skeleton>);
      expect(screen.getByText('Skeleton')).toHaveClass(
        `${rootClass}-${variant}`,
      );
    },
  );

  it('can set width and height in style', () => {
    render(
      <Skeleton width="48px" height="48px">
        Skeleton
      </Skeleton>,
    );
    expect(screen.getByText('Skeleton')).toHaveStyle({
      width: '48px',
      height: '48px',
    });
    expect(screen.getByText('Skeleton')).toMatchSnapshot();
  });
});


================================================================================

组件: Slide
文件: packages/bui-core/src/Slide/Slide.test.tsx
========================================

import React from 'react';
import { render } from 'testing';
import Slide from '.';

it('should render content', () => {
  const { getByTestId } = render(
    <Slide
      in
      direction="down"
      timeout={{
        enter: 2000,
        exit: 1000,
      }}
    >
      <div data-testid="content">滑动效果</div>
    </Slide>,
  );
  expect(getByTestId('content')).toHaveTextContent('滑动效果');
});


================================================================================

组件: Slide
文件: packages/bui-core/src/Slide/__test__/Slide.test.tsx
========================================

import React from 'react';
import { render } from 'testing';
import Slide from '../Slide';

describe('Slide', () => {
  it('renders correctly', () => {
    const { queryByTestId } = render(
      <Slide in direction="down" timeout={1000}>
        <div data-testid="slide-test">slide test</div>
      </Slide>,
    );
    expect(queryByTestId('slide-test')).toHaveStyle(
      'transition: transform 1000ms cubic-bezier(0.4, 0, 0.6, 1) 0ms',
    );
  });
  it.each(['down', 'up', 'left', 'right'])(
    'slides in from different direction',
    (direction) => {
      const { queryByTestId } = render(
        <Slide
          direction={direction as 'down' | 'up' | 'left' | 'right'}
          timeout={{
            enter: 2000,
            exit: 1000,
          }}
        >
          <div data-testid="slide-test">slide test</div>
        </Slide>,
      );
      const getTranslateValue = (_direction) => {
        if (_direction === 'left') {
          return 'translateX(100%)';
        }

        if (_direction === 'right') {
          return 'translateX(-100%)';
        }

        if (_direction === 'up') {
          return 'translateY(100%)';
        }

        // direction === 'down'
        return 'translateY(-100%)';
      };
      expect(queryByTestId('slide-test')).toHaveStyle(
        `transform: ${getTranslateValue(direction)}`,
      );
    },
  );
});


================================================================================

组件: Slider
文件: packages/bui-core/src/Slider/__tests__/Slider.test.tsx
========================================

import React from 'react';
import { act, fireEvent, isConformant, render, screen } from 'testing';
import Slider from '..';

describe('Slider', () => {
  const originalModule = jest.requireActual('@bifrostui/utils');
  const restApi = jest.requireActual('react');
  const rootClass = 'bui-slider';

  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.clearAllTimers();
    jest.useRealTimers();
    jest.clearAllMocks();
  });

  isConformant({
    className: rootClass,
    displayName: 'BuiSlider',
    Component: Slider,
  });

  it('should render with default properties', () => {
    const fakeFn = jest.fn();
    const { container } = render(<Slider value={10} onChange={fakeFn} />);
    const slider = container.querySelector(`.${rootClass}`);
    expect(slider).toMatchSnapshot();
  });

  it('minimum value should controled by `min` property', () => {
    const { container } = render(<Slider min={10} defaultValue={10} />);
    const tooltip = container.querySelector(`.${rootClass}-tooltip`);
    expect(tooltip).toHaveTextContent('10');
  });

  it('maximum value should controled by `max` property', () => {
    const { container } = render(<Slider max={90} defaultValue={90} />);
    const tooltip = container.querySelector(`.${rootClass}-tooltip`);
    expect(tooltip).toHaveTextContent('90');
  });

  it('should render default value by `defaultValue` property', () => {
    const { container } = render(
      <Slider min={20} max={40} defaultValue={30} />,
    );
    const slide = container.querySelector(`.${rootClass}-button-0`);
    expect(slide).toHaveStyle({ left: '50%' });
  });

  it('should render current by `value` property', () => {
    const { container } = render(<Slider min={20} max={40} value={30} />);
    const slide = container.querySelector(`.${rootClass}-button-0`);
    expect(slide).toHaveStyle({ left: '50%' });
  });

  it('tooltip should hidden', () => {
    const { container } = render(<Slider value={0} tipVisible={false} />);
    const tooltip = container.querySelector(`.${rootClass}-tooltip`);
    expect(tooltip).toHaveClass(`${rootClass}-tooltip-hidden`);
  });

  it('tooltip should be formatted by `tooltipRender`', () => {
    const { container } = render(
      <Slider
        value={90}
        tooltipRender={(value) => {
          return <div className="formatter-tips">{value}</div>;
        }}
      />,
    );
    const tooltip = container.querySelector(`.formatter-tips`);
    expect(tooltip).toHaveTextContent('90');
  });

  it('should be disabled', () => {
    const { container } = render(<Slider value={10} disabled />);
    const slider = container.querySelector(`.${rootClass}`);
    expect(slider).toHaveClass(`${rootClass}-disabled`);
  });

  it('should render range', () => {
    const { container } = render(<Slider value={[0, 18]} />);
    const handlers = container.querySelectorAll(`.${rootClass}-button`);
    expect(handlers[0]).toHaveStyle({ left: '0%' });
    expect(handlers[1]).toHaveStyle({ left: '18%' });
  });

  it('should render startIcon', () => {
    const fakeChange = jest.fn();
    const { container } = render(
      <Slider
        value={10}
        startIcon={<div className="icon-start">start</div>}
        onChange={fakeChange}
      />,
    );
    const icon = container.querySelector(`.icon-start`);
    expect(icon).toBeVisible();
  });

  it('should render endIcon', () => {
    const fakeChange = jest.fn();
    const { container } = render(
      <Slider
        value={[10, 20]}
        endIcon={<div className="icon-end">end</div>}
        onChange={fakeChange}
      />,
    );
    const icon = container.querySelector(`.icon-end`);
    expect(icon).toBeVisible();
  });

  it('should trigger touchmove event', async () => {
    render(
      <Slider
        defaultValue={0}
        tooltipRender={(value) => <div>tooltip {value}</div>}
      />,
    );
    await act(async () => {
      await jest.runAllTimers();
    });
    act(() => {
      const button = screen.getByRole('slider');
      const mousedown = new MouseEvent('mousedown', {
        cancelable: true,
        bubbles: true,
      });
      const mousemove = new MouseEvent('mousemove', {
        cancelable: true,
        bubbles: true,
      });
      const touchMove = jest.fn();
      button.addEventListener('touchmove', touchMove, false);

      button.dispatchEvent(mousedown);
      button.dispatchEvent(mousemove);

      expect(touchMove).toBeCalled();
    });
  });

  it('should trigger touchend event', async () => {
    render(
      <Slider
        step={2}
        defaultValue={0}
        tooltipRender={(value) => <div>tooltip {value}</div>}
      />,
    );
    await act(async () => {
      await jest.runAllTimers();
    });
    act(() => {
      const button = screen.getByRole('slider');
      const mousedown = new MouseEvent('mousedown', {
        cancelable: true,
        bubbles: true,
      });
      const mousemove = new MouseEvent('mousemove', {
        cancelable: true,
        bubbles: true,
      });
      const mouseup = new MouseEvent('mouseup', {
        cancelable: true,
        bubbles: true,
      });
      const touchEnd = jest.fn();
      button.addEventListener('touchend', touchEnd, false);

      button.dispatchEvent(mousedown);
      button.dispatchEvent(mousemove);
      button.dispatchEvent(mouseup);

      expect(touchEnd).toBeCalled();
    });
  });

  it('should trigger touchmove event with range mode', async () => {
    const pageX = 30;
    const totalWidth = 300;
    jest.resetModules();
    // mock getBoundingClientRect
    jest.doMock('@bifrostui/utils', () => ({
      ...originalModule,
      getBoundingClientRect: () => {
        return Promise.resolve({
          width: totalWidth,
        });
      },
    }));
    jest.doMock('react', () => ({
      ...restApi,
    }));

    const { default: FakeSlider } = await import('../index');

    render(<FakeSlider defaultValue={[0, 5]} />);
    await act(async () => {
      await jest.runAllTimers();
    });

    const [button1] = screen.getAllByRole('slider');

    fireEvent.touchStart(button1, {
      touches: [
        {
          pageX: 0,
          pageY: 0,
        },
      ],
      cancelable: true,
      bubbles: true,
    });
    fireEvent.touchMove(button1, {
      touches: [
        {
          pageX,
          pageY: 0,
        },
      ],
      cancelable: true,
      bubbles: true,
    });
    // 因为双滑块可交错，第一个按钮移动30的距离后，第二个按钮会在左边，即变成第一个按钮
    // left计算逻辑详见源码
    expect(button1.style.left).toBe(`5%`);
  });

  it('should not swap end button', async () => {
    const pageX = 30;
    const totalWidth = 300;
    jest.resetModules();
    // mock getBoundingClientRect
    jest.doMock('@bifrostui/utils', () => ({
      ...originalModule,
      getBoundingClientRect: () => {
        return Promise.resolve({
          width: totalWidth,
        });
      },
    }));
    jest.doMock('react', () => ({
      ...restApi,
    }));

    const { default: FakeSlider } = await import('../index');

    render(<FakeSlider defaultValue={[0, 5]} disableSwap />);
    await act(async () => {
      await jest.runAllTimers();
    });

    const [button1, button2] = screen.getAllByRole('slider');

    fireEvent.touchStart(button1, {
      touches: [
        {
          pageX: 0,
          pageY: 0,
        },
      ],
      cancelable: true,
      bubbles: true,
    });
    fireEvent.touchMove(button1, {
      touches: [
        {
          pageX,
          pageY: 0,
        },
      ],
      cancelable: true,
      bubbles: true,
    });

    expect(button2.style.left).toBe(`${(pageX / totalWidth) * 100}%`);
  });

  it('should not swap start button', async () => {
    const pageX = 60;
    const totalWidth = 300;
    jest.resetModules();
    // mock getBoundingClientRect
    jest.doMock('@bifrostui/utils', () => ({
      ...originalModule,
      getBoundingClientRect: () => {
        return Promise.resolve({
          width: totalWidth,
        });
      },
    }));
    jest.doMock('react', () => ({
      ...restApi,
    }));

    const { default: FakeSlider } = await import('../index');

    render(<FakeSlider defaultValue={[30, 60]} disableSwap />);
    await act(async () => {
      await jest.runAllTimers();
    });

    const [button1, button2] = screen.getAllByRole('slider');

    fireEvent.touchStart(button2, {
      touches: [
        {
          pageX: 0,
          pageY: 0,
        },
      ],
      cancelable: true,
      bubbles: true,
    });
    fireEvent.touchMove(button2, {
      touches: [
        {
          pageX,
          pageY: 0,
        },
      ],
      cancelable: true,
      bubbles: true,
    });

    expect(button1.style.left).toBe(`${(pageX / totalWidth) * 100}%`);
  });
});


================================================================================

组件: Stack
文件: packages/bui-core/src/Stack/__tests__/Stack.test.tsx
========================================

import React from 'react';
import { render, isConformant } from 'testing';
import Stack from '../Stack';
import { Divider } from '../../Divider';

describe('Stack', () => {
  isConformant({
    Component: Stack,
    displayName: 'BuiStack',
    className: 'bui-stack',
    skip: ['component-has-root-ref', 'component-has-displayname'],
  });

  it.each(['flex-start', 'center', 'flex-end', 'stretch', 'baseline'] as const)(
    'render with alignItems',
    (item) => {
      const { getByText } = render(<Stack alignItems={item}>alignItems</Stack>);
      expect(getByText('alignItems')).toHaveStyle(`--align-items: ${item}`);
    },
  );

  it.each([
    'flex-start',
    'center',
    'flex-end',
    'space-between',
    'space-around',
    'space-evenly',
  ] as const)('render with justifyContent', (item) => {
    const { getByText } = render(
      <Stack justifyContent={item}>justifyContent</Stack>,
    );
    expect(getByText('justifyContent')).toHaveStyle(
      `--justify-content: ${item}`,
    );
  });

  it('render with spacing', () => {
    const { getByText } = render(<Stack spacing="4px">spacing</Stack>);
    expect(getByText('spacing')).toHaveStyle('--spacing: 4px');
  });

  it.each(['row', 'row-reverse', 'column', 'column-reverse'] as const)(
    'render with Direction',
    (direction) => {
      const { getByText } = render(
        <Stack direction={direction}>direction</Stack>,
      );
      expect(getByText('direction')).toHaveStyle(
        `--flex-direction: ${direction}`,
      );
    },
  );
  it('render with divider', () => {
    render(
      <Stack direction="column" divider={<Divider />}>
        <div>divider1</div>
        <div>dividier2</div>
      </Stack>,
    );
    expect(document.querySelector('.bui-divider')).toBeTruthy();
  });
});


================================================================================

组件: Steps
文件: packages/bui-core/src/Steps/__tests__/Steps.test.tsx
========================================

import React from 'react';
import { isConformant, render, userEvent } from 'testing';
import { Step, Steps } from '..';

describe('Steps', () => {
  const rootClass = 'bui-steps';
  const rootStepClass = 'bui-step';

  isConformant({
    className: rootClass,
    displayName: 'Steps',
    Component: Steps,
  });

  it('should be render with default props', () => {
    const { container } = render(
      <Steps>
        <Step key={1} />
        <Step key={2} />
      </Steps>,
    );
    const steps = container.querySelector(`.${rootClass}`);
    expect(steps).toHaveClass(`${rootClass}-vertical`);
    expect(steps.firstChild).toHaveClass(`${rootStepClass}-vertical`);
  });

  it('should be actived by current props', () => {
    const current = 2;
    const { container } = render(
      <Steps current={current}>
        <Step key={1} />
        <Step key={2} />
        <Step key={3} />
        <Step key={4} />
      </Steps>,
    );
    const stepList = container.querySelectorAll(`.${rootStepClass}`);
    stepList.forEach((item, index) => {
      if (index + 1 <= current) {
        expect(item.innerHTML).toContain('bui-step-line-finish');
      }
      if (index === current) {
        expect(item.innerHTML).toContain('bui-step-line-active');
      }
      if (index + 1 === stepList.length) {
        expect(item.innerHTML).toContain('bui-step-line-wait');
      }
    });
  });

  it('direction should be controled by `direction` property', () => {
    const direction = 'horizontal';
    const { container } = render(
      <Steps direction={direction}>
        <Step key={1} />
        <Step key={2} />
      </Steps>,
    );
    const steps = container.querySelector(`.${rootClass}`);
    expect(steps).toHaveClass(`${rootClass}-${direction}`);
    steps.childNodes.forEach((item) => {
      expect(item).toHaveClass(`${rootStepClass}-${direction}`);
    });
  });

  it('title and subtitle direction should be controled by `labelPlacement` property', () => {
    const labelPlacement = 'horizontal';
    const { container } = render(
      <Steps labelPlacement={labelPlacement}>
        <Step key={1} title="标题 1" subtitle="副标题 1" />
        <Step key={2} title="标题 2" subtitle="副标题 2" />
      </Steps>,
    );
    const stepList = container.querySelectorAll(`.${rootStepClass}`);
    stepList.forEach((item) => {
      expect(item).toHaveClass(`${rootStepClass}-label-${labelPlacement}`);
      expect(item.innerHTML).toContain(
        `${rootStepClass}-title-${labelPlacement}`,
      );
      expect(item.innerHTML).toContain(
        `${rootStepClass}-subtitle-${labelPlacement}`,
      );
    });
  });

  it('should be called when click step item', () => {
    const fakeChange = jest.fn((e, { current }) => current);
    const { container } = render(
      <Steps onChange={fakeChange} current={1}>
        <Step key={1} />
        <Step key={2} />
        <Step key={3} />
      </Steps>,
    );
    const stepList = container.querySelectorAll(`.${rootStepClass}`);
    userEvent.click(stepList[0]);
    expect(fakeChange).toReturnWith(1);
  });

  describe('Step', () => {
    it('should be render with default props', () => {
      const { container } = render(
        <Steps>
          <Step key={1} />
          <Step key={2} />
          <Step key={3} />
        </Steps>,
      );
      const steps = container.querySelector(`.${rootClass}`);
      const step = steps.firstChild;
      expect(steps.childElementCount).toBe(3);
      expect(step).toHaveClass(`${rootStepClass}-vertical`);
      expect(step).toHaveClass(`${rootStepClass}-label-horizontal`);
    });

    it('should be render description text when `description` property has value', () => {
      const { container } = render(
        <Steps>
          <Step key={1} description="这是一段描述文案" />
        </Steps>,
      );
      const step = container.querySelector(`.${rootStepClass}`);
      expect(step.innerHTML).toContain(`${rootStepClass}-desc`);
    });

    it('should be render by `icon` property', () => {
      const { container } = render(
        <Steps>
          <Step key={1} icon="1" />
          <Step key={1} icon="2" />
          <Step key={1} icon="3" />
        </Steps>,
      );
      const stepIcons = container.querySelectorAll(`.${rootStepClass}-icon`);
      stepIcons.forEach((item, index) => {
        expect(item).toHaveTextContent(`${index + 1}`);
      });
    });

    it('Step icon should render by icon property', () => {
      const { container } = render(
        <Steps>
          <Step key={1} icon="1" />
          <Step key={1} icon="2" />
          <Step key={1} icon="3" />
          <Step key={1} icon="4" />
        </Steps>,
      );
      const stepIcons = container.querySelectorAll(`.${rootStepClass}-icon`);
      stepIcons.forEach((item, index) => {
        expect(item).toHaveTextContent(`${index + 1}`);
      });
    });

    it('should be render title when `title` property has value', () => {
      const title = 'title';
      const { container } = render(
        <Steps>
          <Step key={1} title={title} />
        </Steps>,
      );
      const stepTitle = container.querySelector(`.${rootStepClass}-title`);
      expect(stepTitle).toHaveTextContent(title);
    });

    it('should be render subtitle when `subtitle` property has value', () => {
      const subtitle = 'subtitle';
      const { container } = render(
        <Steps>
          <Step key={1} subtitle={subtitle} />
        </Steps>,
      );
      const stepSubtitle = container.querySelector(
        `.${rootStepClass}-subtitle`,
      );
      expect(stepSubtitle).toHaveTextContent(subtitle);
    });

    it('Step status should be controled by `status` property', () => {
      const statusList = ['wait', 'active', 'finish', 'error'] as const;
      const { container } = render(
        <Steps>
          {statusList.map((item) => (
            <Step key={item} status={item as (typeof statusList)[number]} />
          ))}
        </Steps>,
      );
      const stepIcons = container.querySelectorAll(`.${rootStepClass}`);
      stepIcons.forEach((item, index) => {
        expect(item.firstChild).toHaveClass(
          `${rootStepClass}-line-${statusList[index]}`,
        );
      });
    });

    it('Step `status` property can change icon', () => {
      const { container } = render(
        <Steps current={2}>
          <Step key={1} />
          <Step key={1} status="error" />
          <Step key={1} />
        </Steps>,
      );
      const stepIcon = container.querySelectorAll(`.${rootStepClass}`)[1];
      expect(stepIcon.firstChild).toHaveClass(`${rootStepClass}-line-error`);
    });

    it('should be disabled when value of true', () => {
      const fakeChange = jest.fn();
      const { container } = render(
        <Steps onChange={fakeChange}>
          <Step key={1} disabled />
          <Step key={2} />
        </Steps>,
      );
      const step = container.querySelectorAll(`.${rootStepClass}`);
      userEvent.click(step[0]);
      expect(fakeChange).not.toHaveBeenCalled();
      userEvent.click(step[1]);
      expect(fakeChange).toHaveBeenCalled();
    });

    it('should be called when click Step item', () => {
      const fakeClick = jest.fn((e, { current }) => current);
      const { container } = render(
        <Steps current={1}>
          <Step key={1} onClick={fakeClick} />
          <Step key={2} onClick={fakeClick} />
        </Steps>,
      );
      const stepsList = container.querySelectorAll(`.${rootStepClass}`);
      userEvent.click(stepsList[0]);
      expect(fakeClick).toHaveBeenCalled();
      expect(fakeClick).toReturnWith(1);
    });
  });
});


================================================================================

组件: Swiper
文件: packages/bui-core/src/Swiper/__test__/Swiper.test.tsx
========================================

import React from 'react';
import { render } from 'testing';
import Swiper from '../Swiper';
import SwiperItem from '../SwiperItem';

describe('Swiper', () => {
  it('renders correctly', () => {
    const { container } = render(
      <Swiper>
        <SwiperItem>
          <div className="demo-text demo-text-1">1</div>
        </SwiperItem>
        <SwiperItem>
          <div className="demo-text demo-text-2">2</div>
        </SwiperItem>
        <SwiperItem>
          <div className="demo-text demo-text-3">3</div>
        </SwiperItem>
      </Swiper>,
    );
    expect(container.querySelector('.swiper-slide')).not.toBeNull();
  });
  it('can be vertical', () => {
    const { container } = render(
      <Swiper vertical>
        <SwiperItem>
          <div className="demo-text demo-text-1">1</div>
        </SwiperItem>
        <SwiperItem>
          <div className="demo-text demo-text-2">2</div>
        </SwiperItem>
        <SwiperItem>
          <div className="demo-text demo-text-3">3</div>
        </SwiperItem>
      </Swiper>,
    );
    expect(container.querySelector('.swiper-vertical')).not.toBeNull();
  });
  it('can be circular', () => {
    const { container } = render(
      <Swiper circular>
        <SwiperItem>
          <div className="demo-text demo-text-1">1</div>
        </SwiperItem>
        <SwiperItem>
          <div className="demo-text demo-text-2">2</div>
        </SwiperItem>
        <SwiperItem>
          <div className="demo-text demo-text-3">3</div>
        </SwiperItem>
      </Swiper>,
    );
    expect(container.querySelector('.swiper-slide-duplicate')).not.toBeNull();
  });
  it('can set indicator color', () => {
    const { container } = render(
      <Swiper
        indicatorDots
        indicatorColor="#123456"
        indicatorActiveColor="#654321"
      >
        <SwiperItem>
          <div className="demo-text demo-text-1">1</div>
        </SwiperItem>
        <SwiperItem>
          <div className="demo-text demo-text-2">2</div>
        </SwiperItem>
        <SwiperItem>
          <div className="demo-text demo-text-3">3</div>
        </SwiperItem>
      </Swiper>,
    );
    expect(container.querySelector('.bui-swiper')).toHaveStyle(
      '--indicator-color: #123456; --indicator-color-active: #654321',
    );
  });
  it('can set margin', () => {
    const { container } = render(
      <Swiper previousMargin="20px" nextMargin="30px">
        <SwiperItem>
          <div className="demo-text demo-text-1">1</div>
        </SwiperItem>
        <SwiperItem>
          <div className="demo-text demo-text-2">2</div>
        </SwiperItem>
        <SwiperItem>
          <div className="demo-text demo-text-3">3</div>
        </SwiperItem>
      </Swiper>,
    );
    expect(container.querySelector('.bui-swiper')).toHaveStyle(
      'padding: 0px 30px 0px 20px',
    );
  });
  // swiper在单测环境中不工作，所以无法测试内部逻辑
  // see: https://github.com/nolimits4web/swiper/issues/5722
  // it('can slide to current state', async () => {
  //   const { container, rerender } = render(
  //     <Swiper current={0} duration={0}>
  //       <SwiperItem>
  //         <div className="demo-text demo-text-1">1</div>
  //       </SwiperItem>
  //       <SwiperItem>
  //         <div className="demo-text demo-text-2">2</div>
  //       </SwiperItem>
  //       <SwiperItem>
  //         <div className="demo-text demo-text-3">3</div>
  //       </SwiperItem>
  //     </Swiper>,
  //   );
  //   await waitFor(() => {
  //     expect(container.querySelector('.swiper-slide-active')).not.toBeNull();
  //   });
  //   rerender(
  //     <Swiper current={1} duration={0}>
  //       <SwiperItem>
  //         <div className="demo-text demo-text-1">1</div>
  //       </SwiperItem>
  //       <SwiperItem>
  //         <div className="demo-text demo-text-2">2</div>
  //       </SwiperItem>
  //       <SwiperItem>
  //         <div className="demo-text demo-text-3">3</div>
  //       </SwiperItem>
  //     </Swiper>,
  //   );
  //   await waitFor(() => {
  //     expect(
  //       container.querySelector('.swiper-slide-active .demo-text-2'),
  //     ).not.toBeNull();
  //   });
  // });
});


================================================================================

组件: Switch
文件: packages/bui-core/src/Switch/__test__/Switch.test.tsx
========================================

import React, { useState } from 'react';
import { fireEvent, isConformant, render, screen } from 'testing';
import Switch from '../Switch';

describe('Switch', () => {
  const classPrefix = 'bui-switch';

  isConformant({
    className: classPrefix,
    displayName: 'BuiSwitch',
    Component: Switch,
  });
  it('should render correctly', async () => {
    const { container } = render(<Switch />);
    const [switchDom] = [...container.getElementsByClassName(classPrefix)];
    // 测试渲染
    expect(switchDom).toHaveClass(`${classPrefix}-medium`);
    expect(switchDom).toHaveClass(`${classPrefix}-primary`);
    expect(switchDom).not.toHaveClass(`${classPrefix}-disabled`);
  });

  it('should be checked', () => {
    render(<Switch defaultChecked>Switch</Switch>);
    const checkbox = screen.getByRole<HTMLInputElement>('checkbox');
    expect(checkbox.checked).toBeTruthy();
  });

  it('should be disabled', () => {
    render(
      <Switch disabled data-testid="switch">
        switch
      </Switch>,
    );
    expect(screen.getByTestId('switch')).toHaveClass(`${classPrefix}-disabled`);
    expect(screen.getByRole('checkbox')).toHaveAttribute('disabled');
  });

  it('should use custom unchecked icon', () => {
    const uncheckedIcon = 'icon';
    const { getByTestId } = render(
      <Switch
        unCheckedChildren={uncheckedIcon}
        data-testid="switch-customize"
      />,
    );
    expect(getByTestId('switch-customize')).toHaveTextContent('icon');
  });

  it('should use custom checked icon', () => {
    const checkedIcon = <div className="test-checked-icon">icon</div>;
    render(<Switch checkedChildren={checkedIcon} defaultChecked />);
    const icon = screen.getByText('icon');
    expect(icon).toBeVisible();
  });

  it('should render with custom color', () => {
    const { container } = render(<Switch color="success" defaultChecked />);
    expect(container.querySelectorAll(`.${classPrefix}-success`).length).toBe(
      1,
    );
  });

  it('should render with custom size', () => {
    const { container } = render(<Switch size="small" />);
    expect(container.querySelectorAll(`.${classPrefix}-small`).length).toBe(1);
  });

  it('should call onChange', async () => {
    const changeFn = jest.fn();
    function Component() {
      const [checked] = useState(false);
      return <Switch checked={checked} onChange={changeFn} />;
    }
    render(<Component />);
    const switchDom = screen.getByRole('checkbox');
    fireEvent.click(switchDom);
    expect(changeFn).toBeCalled();
  });
});


================================================================================

组件: TabBar
文件: packages/bui-core/src/TabBar/__tests__/TabBar.snapshotTest.test.tsx
========================================

import { snapshotTest } from 'testing';

describe('TabBar snapshot', () => {
  snapshotTest('TabBar');
});


================================================================================

组件: TabBar
文件: packages/bui-core/src/TabBar/__tests__/TabBar.test.tsx
========================================

import React from 'react';
import {
  HomeFilledIcon,
  PhoneFilledIcon,
  StoreFilledIcon,
} from '@bifrostui/icons';
import { render, isConformant, screen, userEvent } from 'testing';
import TabBar from '../TabBar';
import TabBarItem from '../TabBarItem';

describe('TabBar', () => {
  isConformant({
    Component: TabBar,
    displayName: 'BuiTabBar',
    className: 'bui-tab-bar',
  });
  it('should render current', () => {
    render(
      <TabBar>
        <TabBarItem title="主页" />
        <TabBarItem title="想看" />
        <TabBarItem title="反馈" />
      </TabBar>,
    );
    expect(screen.getByText('主页').parentNode).toHaveClass(
      'bui-tab-bar-item-active',
    );
    expect(screen.getByText('主页')).toBeTruthy();
    expect(screen.getByText('想看')).toBeTruthy();
    expect(screen.getByText('反馈')).toBeTruthy();
  });
  it('should render  default value current', () => {
    render(
      <TabBar current={2}>
        <TabBarItem title="主页" />
        <TabBarItem title="想看" />
        <TabBarItem title="反馈" />
      </TabBar>,
    );
    expect(screen.getByText('反馈').parentNode).toHaveClass(
      'bui-tab-bar-item-active',
    );
  });
  it('should render icon current', () => {
    render(
      <TabBar>
        <TabBarItem title="主页" icon={<HomeFilledIcon />} />
        <TabBarItem title="商店" icon={<StoreFilledIcon />} />
        <TabBarItem title="帮助" icon={<PhoneFilledIcon />} />
      </TabBar>,
    );
    expect(document.querySelector('.bui-svg-icon')).toBeTruthy();
  });
  it('should render active icon current', () => {
    render(
      <TabBar>
        <TabBarItem
          title="主页"
          icon={<HomeFilledIcon />}
          activeIcon={<div>图标</div>}
        />
        <TabBarItem title="商店" icon={<StoreFilledIcon />} />
        <TabBarItem title="帮助" icon={<PhoneFilledIcon />} />
      </TabBar>,
    );

    expect(screen.getByText('图标')).toBeTruthy();
  });
  it('should render color current', () => {
    render(
      <TabBar color="info">
        <TabBarItem title="主页" icon={<HomeFilledIcon />} />
        <TabBarItem title="商店" icon={<StoreFilledIcon />} />
        <TabBarItem title="帮助" icon={<PhoneFilledIcon />} />
      </TabBar>,
    );

    expect(screen.getByText('商店')).toHaveClass('bui-tab-bar-item-info');
  });
  it('should render active color current', () => {
    render(
      <TabBar activeColor="info">
        <TabBarItem title="主页" icon={<HomeFilledIcon />} />
        <TabBarItem title="商店" icon={<StoreFilledIcon />} />
        <TabBarItem title="帮助" icon={<PhoneFilledIcon />} />
      </TabBar>,
    );
    expect(screen.getByText('主页')).toHaveClass('bui-tab-bar-item-info');
  });
  it('should render BadgeProps current', () => {
    render(
      <TabBar activeColor="info">
        <TabBarItem
          title="主页"
          icon={<HomeFilledIcon />}
          BadgeProps={{ content: 20 }}
        />
        <TabBarItem title="商店" icon={<StoreFilledIcon />} />
        <TabBarItem title="帮助" icon={<PhoneFilledIcon />} />
      </TabBar>,
    );
    expect(screen.getByText('20')).toBeTruthy();
    expect(document.querySelector('.bui-badge')).toBeTruthy();
  });
  it('should pass value as part of event.target of change', () => {
    const onChange = jest.fn((e, value) => value);
    render(
      <TabBar activeColor="info" onChange={onChange}>
        <TabBarItem title="主页" icon={<HomeFilledIcon />} />
        <TabBarItem title="商店" icon={<StoreFilledIcon />} />
        <TabBarItem title="帮助" icon={<PhoneFilledIcon />} />
      </TabBar>,
    );
    userEvent.click(screen.getByText('商店'));
    expect(onChange).toReturnWith({ value: 1 });
  });
});


================================================================================

组件: Tabs
文件: packages/bui-core/src/Tabs/__tests__/Tabs.test.tsx
========================================

import React, { useState } from 'react';
import { fireEvent, isConformant, render, act } from 'testing';
import { TabPanel, Tabs, Tab } from '..';

describe('Tabs', () => {
  const originalModule = jest.requireActual('@bifrostui/utils');
  const restApi = jest.requireActual('react');
  const rootClass = {
    tabs: 'bui-tabs',
    tabpanel: 'bui-tabpanel',
  };

  beforeEach(() => {
    document.body.innerHTML = '';
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.clearAllTimers();
    jest.useRealTimers();
    jest.clearAllMocks();
  });

  isConformant({
    Component: Tabs,
    displayName: 'BuiTabs',
    className: rootClass.tabs,
    requiredProps: {
      tabs: [
        { title: '水果', index: 'fruits' },
        { title: '蔬菜', index: 'vegetables' },
        { title: '动物', index: 'animals' },
      ],
    },
  });

  it('should render by tabs', () => {
    function Component() {
      return (
        <Tabs
          value="fruits"
          tabs={[
            { title: '水果', index: 'fruits' },
            { title: '蔬菜', index: 'vegetables' },
            { title: '动物', index: 'animals' },
          ]}
        />
      );
    }
    const { container } = render(<Component />);

    const tabs = container.querySelectorAll(`.bui-tab`);
    expect(tabs.length).toBe(3);
    expect(tabs[0]).toHaveTextContent('水果');
    expect(tabs[1]).toHaveTextContent('蔬菜');
    expect(tabs[2]).toHaveTextContent('动物');
  });

  it('should render with default property', () => {
    function Component() {
      return (
        <Tabs
          value="fruits"
          tabs={[
            { title: '水果', index: 'fruits' },
            { title: '蔬菜', index: 'vegetables' },
            { title: '动物', index: 'animals' },
          ]}
        />
      );
    }
    const { container } = render(<Component />);

    const tabLine = container.querySelector(`.${rootClass.tabs}-tabline`);
    expect(tabLine).toHaveStyle({
      transform: 'translate3d(0px, 0px, 0px)',
      transition: 'transform 0.25s ease-in-out',
    });
  });

  it('should full container', () => {
    function Component() {
      return (
        <div style={{ width: '375px' }}>
          <Tabs
            value="vegetables"
            tabs={[
              { title: '水果', index: 'fruits' },
              { title: '蔬菜', index: 'vegetables' },
              { title: '动物', index: 'animals' },
            ]}
          />
        </div>
      );
    }

    const { container } = render(<Component />);
    const tabWrapperList = container.querySelectorAll(
      `.${rootClass.tabs}-tab-wrapper`,
    );
    tabWrapperList.forEach((item) => {
      expect(item).toHaveStyle({ flex: '1 0 auto' });
    });
  });

  describe('test with TabPanel', () => {
    it('should be actived by `value` property', () => {
      function Component() {
        const [value] = useState('vegetables');
        return (
          <div data-testid="test-wrapper">
            <Tabs
              value="vegetables"
              tabs={[
                { title: '水果', index: 'fruits' },
                { title: '蔬菜', index: 'vegetables' },
                { title: '动物', index: 'animals' },
              ]}
            />
            <TabPanel value={value} index="fruits">
              菠萝
            </TabPanel>
            <TabPanel value={value} index="vegetables">
              西红柿
            </TabPanel>
            <TabPanel value={value} index="animals">
              大象
            </TabPanel>
          </div>
        );
      }
      const { container, getByTestId } = render(<Component />);

      const tabLine = container.querySelector(`.${rootClass.tabs}-tabline`);
      const activePabel = container.querySelector(
        `.${rootClass.tabpanel}-active`,
      );
      expect(tabLine).toBeVisible();
      expect(activePabel).toHaveTextContent('西红柿');
      expect(getByTestId('test-wrapper')).toMatchSnapshot();
    });

    it('`onChange` event should be called', () => {
      function Component() {
        const [value, setValue] = useState('fruits');
        const handleChange = (e, { index }) => {
          setValue(index);
        };
        return (
          <>
            <Tabs
              className="tabs-test"
              onChange={handleChange}
              value={value}
              tabs={[
                { title: '水果', index: 'fruits' },
                { title: '蔬菜', index: 'vegetables' },
                { title: '动物', index: 'animals' },
              ]}
            />
            <TabPanel value={value} index="fruits">
              菠萝
            </TabPanel>
            <TabPanel value={value} index="vegetables">
              西红柿
            </TabPanel>
            <TabPanel value={value} index="animals">
              大象
            </TabPanel>
          </>
        );
      }

      const { container } = render(<Component />);
      const [, tab2] = container.querySelectorAll(`.bui-tab`);
      fireEvent.click(tab2);
      const activeTab = container.querySelector(`.bui-tab-active`);
      const activeTabPanel = container.querySelector(
        `.${rootClass.tabpanel}-active`,
      );
      expect(activeTab).toHaveTextContent('蔬菜');
      expect(activeTabPanel).toHaveTextContent('西红柿');
    });

    it('should save children nodes when `keepMounted` is true', () => {
      function Component() {
        const [value, setValue] = useState('fruits');
        const handleChange = (e, { index }) => {
          setValue(index);
        };
        return (
          <>
            <Tabs
              className="tabs-test"
              onChange={handleChange}
              value={value}
              tabs={[
                { title: '水果', index: 'fruits' },
                { title: '蔬菜', index: 'vegetables' },
                { title: '动物', index: 'animals' },
              ]}
            />
            <TabPanel keepMounted value={value} index="fruits">
              菠萝
            </TabPanel>
            <TabPanel keepMounted value={value} index="vegetables">
              西红柿
            </TabPanel>
            <TabPanel value={value} index="animals">
              大象
            </TabPanel>
          </>
        );
      }

      const { container } = render(<Component />);
      const [, tab2, tab3] = container.querySelectorAll(`.bui-tab`);
      const [tabpanel1, tabpanel2, tabpanel3] = container.querySelectorAll(
        `.${rootClass.tabpanel}`,
      );
      expect(tabpanel2).toHaveTextContent('西红柿');
      expect(tabpanel3).toHaveTextContent('');
      fireEvent.click(tab3);
      expect(tabpanel3).toHaveTextContent('大象');
      fireEvent.click(tab2);
      expect(tabpanel1).toHaveTextContent('菠萝');
      expect(tabpanel3).toHaveTextContent('');
    });

    it('should disable click', () => {
      const handleChange = jest.fn();
      function Component(props: { handleChange: any }) {
        const { handleChange: change } = props;
        const [value] = useState('fruits');
        return (
          <>
            <Tabs
              className="tabs-test"
              onChange={change}
              value={value}
              tabs={[
                { title: '水果', index: 'fruits' },
                { title: '蔬菜', index: 'vegetables', disabled: true },
                { title: '动物', index: 'animals' },
              ]}
            />
            <TabPanel keepMounted value={value} index="fruits">
              菠萝
            </TabPanel>
            <TabPanel keepMounted value={value} index="vegetables">
              西红柿
            </TabPanel>
            <TabPanel value={value} index="animals">
              大象
            </TabPanel>
          </>
        );
      }

      const { container } = render(<Component handleChange={handleChange} />);
      const [, tab2] = container.querySelectorAll(`.bui-tab`);
      fireEvent.click(tab2);
      expect(handleChange).not.toBeCalled();
    });

    it('should active default Tab when got error value', () => {
      function Component() {
        const [value, setValue] = useState('vegetables111');
        const handleChange = (e, { index }) => {
          setValue(index);
        };
        return (
          <>
            <Tabs
              className="tabs-test"
              onChange={handleChange}
              value={value}
              tabs={[]}
            />
            <TabPanel keepMounted value={value} index="fruits">
              菠萝
            </TabPanel>
            <TabPanel keepMounted value={value} index="vegetables">
              西红柿
            </TabPanel>
            <TabPanel value={value} index="animals">
              大象
            </TabPanel>
          </>
        );
      }

      const { container } = render(<Component />);
      const tabline = container.querySelector(`.bui-tabs-tabline`);
      expect(tabline).toHaveClass('bui-tabs-tabline');
    });
  });

  it('should render when resize', async () => {
    jest.resetModules();
    jest.doMock('@bifrostui/utils', () => ({
      ...originalModule,
      debounce: jest.fn((fn) => fn),
    }));
    jest.doMock('react', () => ({
      ...restApi,
    }));
    const { default: FakeTabs } = await import('../index');

    function Component() {
      const [value, setValue] = useState('fruits');
      const handleChange = (e, { index }) => {
        setValue(index);
      };
      return (
        <>
          <FakeTabs
            className="tabs-test"
            onChange={handleChange}
            value={value}
            tabs={[
              { title: '水果', index: 'fruits' },
              { title: '蔬菜', index: 'vegetables' },
              { title: '动物', index: 'animals' },
            ]}
          />
          <TabPanel value={value} index="fruits">
            菠萝
          </TabPanel>
          <TabPanel value={value} index="vegetables">
            西红柿
          </TabPanel>
          <TabPanel value={value} index="animals">
            大象
          </TabPanel>
        </>
      );
    }

    const { container } = render(<Component />);
    await act(async () => {
      await jest.runAllTimers();
    });

    act(() => {
      global.dispatchEvent(new Event('resize'));
      const [, tab2] = container.querySelectorAll(`.bui-tab`);
      fireEvent.click(tab2);
    });
    const activeTab = container.querySelector(`.bui-tab-active`);
    const activeTabPanel = container.querySelector(
      `.${rootClass.tabpanel}-active`,
    );
    expect(activeTab).toHaveTextContent('蔬菜');
    expect(activeTabPanel).toHaveTextContent('西红柿');
  });

  it('should no active Tab when value is invalid', () => {
    function Component() {
      const [value, setValue] = useState('2');
      const defultList = [
        { title: '长津湖', index: '1' },
        { title: '战狼2', index: '2' },
        { title: '你好，李焕英', index: '3' },
        { title: '哪吒之魔童降世', index: '4' },
        { title: '流浪地球', index: '5' },
        { title: '唐人街探案3', index: '6' },
      ];
      const [tabList, setTabList] = useState(defultList);

      const handleChange = (e, { index }) => {
        setValue(index);
      };

      return (
        <>
          <div
            data-testid="test-invalid-value"
            onClick={() => {
              setValue('');
            }}
          >
            置为无效值
          </div>
          <div
            data-testid="test-modify-tablist"
            onClick={() => {
              if (tabList.length === 4) {
                setTabList(defultList);
              } else {
                const newTabList = defultList.slice(0, 4);
                setTabList(newTabList);
                if (!newTabList.some((item) => item.index === value)) {
                  setValue('1');
                }
              }
            }}
          >
            {tabList.length === 4 ? '增加' : '减少'}TabList长度
          </div>
          <div style={{ width: '325px' }}>
            <Tabs
              style={{ marginTop: '20px', marginBottom: '12px' }}
              value={value}
              onChange={handleChange}
            >
              {tabList.map((item) => (
                <Tab key={item.index} {...item}>
                  {item.title}
                </Tab>
              ))}
            </Tabs>

            {tabList.map((item) => (
              <TabPanel key={item.index} value={value} index={item.index}>
                {item.index}
              </TabPanel>
            ))}
          </div>
        </>
      );
    }

    const { container, getByTestId } = render(<Component />);

    const testInvalidValueBtn = getByTestId('test-invalid-value');
    const [, , tab3] = container.querySelectorAll(`.bui-tab`);
    const tabpanels = container.querySelectorAll(`.${rootClass.tabpanel}`);

    tabpanels.forEach((tabpanel, index) => {
      if (index === 1) {
        expect(tabpanel).toHaveTextContent('2');
      } else {
        expect(tabpanel).toHaveTextContent('');
      }
    });

    fireEvent.click(testInvalidValueBtn);
    tabpanels.forEach((tabpanel) => {
      expect(tabpanel).toHaveTextContent('');
    });

    fireEvent.click(tab3);
    tabpanels.forEach((tabpanel, index) => {
      if (index === 2) {
        expect(tabpanel).toHaveTextContent('3');
      } else {
        expect(tabpanel).toHaveTextContent('');
      }
    });
  });

  it('should no active Tab when value is invalid by use tabs', () => {
    function Component() {
      const [value, setValue] = useState('2');
      const defultList = [
        { title: '长津湖', index: '1' },
        { title: '战狼2', index: '2' },
        { title: '你好，李焕英', index: '3' },
        { title: '哪吒之魔童降世', index: '4' },
        { title: '流浪地球', index: '5' },
        { title: '唐人街探案3', index: '6' },
      ];
      const [tabList, setTabList] = useState(defultList);

      const handleChange = (e, { index }) => {
        setValue(index);
      };

      return (
        <>
          <div
            data-testid="test-invalid-value"
            onClick={() => {
              setValue('');
            }}
          >
            置为无效值
          </div>
          <div
            data-testid="test-modify-tablist"
            onClick={() => {
              if (tabList.length === 4) {
                setTabList(defultList);
              } else {
                const newTabList = defultList.slice(0, 4);
                setTabList(newTabList);
                if (!newTabList.some((item) => item.index === value)) {
                  setValue('1');
                }
              }
            }}
          >
            {tabList.length === 4 ? '增加' : '减少'}TabList长度
          </div>
          <div style={{ width: '325px' }}>
            <Tabs
              style={{ marginTop: '20px', marginBottom: '12px' }}
              value={value}
              tabs={tabList}
              onChange={handleChange}
            />

            {tabList.map((item) => (
              <TabPanel key={item.index} value={value} index={item.index}>
                {item.index}
              </TabPanel>
            ))}
          </div>
        </>
      );
    }

    const { container, getByTestId } = render(<Component />);

    const testInvalidValueBtn = getByTestId('test-invalid-value');
    const [, , tab3] = container.querySelectorAll(`.bui-tab`);
    const tabpanels = container.querySelectorAll(`.${rootClass.tabpanel}`);

    tabpanels.forEach((tabpanel, index) => {
      if (index === 1) {
        expect(tabpanel).toHaveTextContent('2');
      } else {
        expect(tabpanel).toHaveTextContent('');
      }
    });

    fireEvent.click(testInvalidValueBtn);
    tabpanels.forEach((tabpanel) => {
      expect(tabpanel).toHaveTextContent('');
    });

    fireEvent.click(tab3);
    tabpanels.forEach((tabpanel, index) => {
      if (index === 2) {
        expect(tabpanel).toHaveTextContent('3');
      } else {
        expect(tabpanel).toHaveTextContent('');
      }
    });
  });

  it('should render correctly when TabList changed', async () => {
    function Component() {
      const [value, setValue] = useState('2');
      const defultList = [
        { title: '长津湖', index: '1' },
        { title: '战狼2', index: '2' },
        { title: '你好，李焕英', index: '3' },
        { title: '哪吒之魔童降世', index: '4' },
        { title: '流浪地球', index: '5' },
        { title: '唐人街探案3', index: '6' },
      ];
      const [tabList, setTabList] = useState(defultList);

      const handleChange = (e, { index }) => {
        setValue(index);
      };

      return (
        <>
          <div
            data-testid="test-modify-tablist2"
            onClick={() => {
              if (tabList.length === 4) {
                setTabList(defultList);
              } else {
                const newTabList = defultList.slice(0, 4);
                setTabList(newTabList);
                if (!newTabList.some((item) => item.index === value)) {
                  setValue('1');
                }
              }
            }}
          >
            {tabList.length === 4 ? '增加' : '减少'}TabList长度
          </div>
          <div style={{ width: '325px' }}>
            <Tabs
              style={{ marginTop: '20px', marginBottom: '12px' }}
              value={value}
              onChange={handleChange}
            >
              {tabList.map((item) => (
                <Tab key={item.index} {...item}>
                  {item.title}
                </Tab>
              ))}
            </Tabs>

            {tabList.map((item) => (
              <TabPanel key={item.index} value={value} index={item.index}>
                {item.index}
              </TabPanel>
            ))}
          </div>
        </>
      );
    }

    const { container, getByTestId } = render(<Component />);

    const testModifyTablistBtn = getByTestId('test-modify-tablist2');
    const [tab1, , , , , tab6] = container.querySelectorAll(`.bui-tab`);
    const tabpanels = container.querySelectorAll(`.${rootClass.tabpanel}`);
    const [tabpanel1] = tabpanels;

    tabpanels.forEach((tabpanel, index) => {
      if (index === 1) {
        expect(tabpanel).toHaveTextContent('2');
      } else {
        expect(tabpanel).toHaveTextContent('');
      }
    });

    fireEvent.click(tab6);
    tabpanels.forEach((tabpanel, index) => {
      if (index === 5) {
        expect(tabpanel).toHaveTextContent('6');
      } else {
        expect(tabpanel).toHaveTextContent('');
      }
    });

    fireEvent.click(testModifyTablistBtn);
    expect(tab1).toHaveClass('bui-tab-active');
    expect(tabpanel1).toHaveTextContent('1');

    fireEvent.click(testModifyTablistBtn);
    expect(tab1).toHaveClass('bui-tab-active');
    expect(tabpanel1).toHaveTextContent('1');
  });
});


================================================================================

组件: Tag
文件: packages/bui-core/src/Tag/__tests__/Tag.test.tsx
========================================

import React from 'react';
import { fireEvent, render, isConformant } from 'testing';
import Tag from '../Tag';

describe('Tag', () => {
  const rootClass = 'bui-tag';

  isConformant({
    className: rootClass,
    Component: Tag,
    displayName: 'BuiTag',
  });

  it('should render default content', () => {
    const component = render(<Tag>default</Tag>);
    const tag = component.container;
    expect(tag).toHaveTextContent('default');
  });

  it('should be clickable', () => {
    const fakeClick = jest.fn();
    const { container } = render(<Tag onClick={fakeClick} />);
    const tag = container.querySelectorAll(`.${rootClass}`)[0];
    fireEvent.click(tag);
    expect(fakeClick).toBeCalled();
  });

  it('should have color className', () => {
    const colors = ['primary', 'info', 'success', 'warning', 'danger'] as const;

    colors.forEach((color) => {
      const { container } = render(
        <Tag color={color as (typeof colors)[number]} />,
      );
      expect(container.firstChild).toHaveClass(`${rootClass}-${color}`);
    });
  });

  it('should render with htmlColor currently when outlined', () => {
    const htmlColor = '#666666';
    const { container } = render(
      <Tag variant="outlined" htmlColor={htmlColor} />,
    );
    const target = container.querySelector<HTMLDivElement>(`.${rootClass}`);
    expect(container.querySelector(`.${rootClass}`)).toHaveStyle(
      `color: ${htmlColor}`,
    );
    expect(target?.style['border-color']).toContain('0.4');
  });

  it('should render with htmlColor currently when contained', () => {
    const htmlColor = '#666666';
    const { container } = render(
      <Tag variant="contained" htmlColor={htmlColor} />,
    );
    expect(container.querySelector(`.${rootClass}`)).toHaveStyle(
      `background-color: ${htmlColor}`,
    );
  });
  it('should render with htmlColor currently  when light', () => {
    const htmlColor = '#666666';
    const { container } = render(<Tag variant="light" htmlColor={htmlColor} />);
    const target = container.querySelector<HTMLDivElement>(`.${rootClass}`);
    expect(container.querySelector(`.${rootClass}`)).toHaveStyle(
      `color: ${htmlColor}`,
    );
    expect(target?.style['background-color']).toContain('0.3');
  });

  it.each(['rgb(102,102,102)', 'rgba(102,102,102,0.5)'] as const)(
    'should render rgba/rgb htmlColor currently',
    (color) => {
      const { container } = render(
        <Tag variant="outlined" htmlColor={color} />,
      );
      const target = container.querySelector<HTMLDivElement>(`.${rootClass}`);
      expect(target?.style['border-color']).toContain('0.4');
      expect(container.querySelector(`.${rootClass}`)).toHaveStyle(
        `color: ${color}`,
      );
    },
  );

  it('should have variant className', () => {
    const variants = ['outlined', 'contained'] as const;

    variants.forEach((variant) => {
      const { container } = render(
        <Tag variant={variant as (typeof variants)[number]} />,
      );
      expect(container.firstChild).toHaveClass(`${rootClass}-${variant}`);
    });
  });
});


================================================================================

组件: Tag
文件: packages/bui-core/src/Tag/__tests__/TagGroup.test.tsx
========================================

import { fireEvent, isConformant, render } from 'testing';
import React from 'react';
import TagGroup from '../TagGroup';

describe('TagGroup', () => {
  const rootClass = 'bui-tag-group';

  isConformant({
    className: rootClass,
    displayName: 'BuiTagGroup',
    Component: TagGroup,
  });

  it('should render default content', () => {
    const component = render(<TagGroup>default</TagGroup>);
    const tag = component.container;
    expect(tag).toHaveTextContent('default');
  });

  it('should be clickable', () => {
    const fakeClick = jest.fn();
    const { container } = render(<TagGroup onClick={fakeClick} />);
    const tagGroup = container.querySelectorAll(`.${rootClass}`)[0];
    fireEvent.click(tagGroup);
    expect(fakeClick).toBeCalled();
  });
});


================================================================================

组件: TextArea
文件: packages/bui-core/src/TextArea/__tests__/TextArea.test.tsx
========================================

import React from 'react';
import { fireEvent, isConformant, render, screen, userEvent } from 'testing';
import { TextArea } from '..';

describe('TextArea', () => {
  const rootClass = 'bui-textarea';

  isConformant({
    className: rootClass,
    displayName: 'BuiTextArea',
    Component: TextArea,
    skip: [
      'component-has-root-ref',
      'component-handles-classNames',
      'component-handles-style',
    ],
  });

  it('should render with value', () => {
    render(<TextArea value="123" />);
    const textarea = screen.getByRole('textbox');
    expect(textarea).toHaveValue('123');
  });

  it('should controlled by value', () => {
    const handleChange = jest.fn((e, data) => data.value);
    render(<TextArea placeholder="textarea" onChange={handleChange} />);
    const textarea = screen.getByRole('textbox');
    userEvent.type(textarea, '1234');
    expect(handleChange).toReturnWith('1234');
    expect(textarea).toHaveValue('1234');
  });

  it('should render with defaultValue', () => {
    render(<TextArea defaultValue="234" />);
    const textarea = screen.getByRole('textbox');
    expect(textarea).toHaveValue('234');
  });

  it('should render placeholder', () => {
    render(<TextArea placeholder="place input content" />);
    const textarea = screen.getByRole('textbox');
    expect((textarea as HTMLTextAreaElement).placeholder).toBe(
      'place input content',
    );
  });

  it('should render by rows', () => {
    render(<TextArea rows={3} />);
    const textarea = screen.getByRole('textbox');
    expect((textarea as HTMLTextAreaElement).rows).toBe(3);
  });

  it('should have max length', () => {
    render(<TextArea maxLength={10} />);
    const textarea = screen.getByRole('textbox');
    expect((textarea as HTMLTextAreaElement).maxLength).toBe(10);
  });

  it('can auto size', () => {
    render(
      <TextArea
        autoSize
        value="test autoSize.test autoSize.test autoSize.test autoSize.test autoSize.test autoSize.test autoSize.test autoSize.test autoSize.test autoSize.test autoSize."
      />,
    );
    const textarea = screen.getByRole('textbox');
    expect(textarea).toMatchSnapshot();
  });

  it('can auto size', () => {
    render(<TextArea autoSize={{ minHeight: 50, maxHeight: 100 }} />);
    const textarea = screen.getByRole('textbox');

    Object.defineProperty(textarea, 'scrollHeight', {
      value: 30,
      configurable: true,
    });
    fireEvent.change(textarea, { target: { value: '1' } });
    expect(textarea.style.height).toBe(`30px`);

    Object.defineProperty(textarea, 'scrollHeight', {
      value: 200,
    });
    fireEvent.change(textarea, {
      target: {
        value:
          'test autoSize.test autoSize.test autoSize.test autoSize.test autoSize.test autoSize.test autoSize.test autoSize.test autoSize.test autoSize.test autoSize.',
      },
    });
    expect(textarea.style.height).toBe(`100px`);
  });

  it('should auto focus', () => {
    render(<TextArea autoFocus />);
    const textarea = screen.getByRole('textbox');
    expect(document.activeElement).toBe(textarea);
  });

  it('should show input count', () => {
    const { container } = render(<TextArea value="test" showCount />);
    const count = container.querySelector(`.${rootClass}-count`);
    expect(count).toBeInTheDocument();
    expect(count).toHaveTextContent('4');
  });

  it('trigger on change', () => {
    const fakeChange = jest.fn((e, v) => v.value);
    render(<TextArea onChange={fakeChange} />);
    const textarea = screen.getByRole('textbox');
    userEvent.type(textarea, '1234');
    expect(fakeChange).toReturnWith('1234');
  });

  it('trigger focus', () => {
    render(<TextArea value="test" />);

    const textarea = screen.getByRole('textbox');
    textarea.focus();
    expect(textarea).toHaveFocus();
  });

  it('trigger blur', () => {
    render(<TextArea value="test" />);

    const textarea = screen.getByRole('textbox');
    textarea.focus();
    expect(textarea).toHaveFocus();
    textarea.blur();
    expect(textarea).not.toHaveFocus();
  });
});


================================================================================

组件: ThemeProvider
文件: packages/bui-core/src/ThemeProvider/__tests__/ThemeProvider.test.tsx
========================================

import React from 'react';
import { render, userEvent, screen } from 'testing';
import dayjs from 'dayjs/esm/index';
import {
  ThemeProvider,
  Calendar,
  EN,
  CN,
  TW,
  Dialog,
  Button,
} from '@bifrostui/react';
import { renderHook } from '@testing-library/react';

describe('ThemeProvider', () => {
  let dialogHook;
  beforeEach(() => {
    renderHook(() => {
      dialogHook = Dialog.useDialog();
    });
  });
  it.each([
    { locale: EN, type: 'EN' },
    { locale: CN, type: 'CN' },
    { locale: TW, type: 'TW' },
  ])('should render Component locale theme currently', (theme) => {
    const placeHolder = {
      EN: 'Sat',
      CN: '六',
      TW: '六',
    };
    render(
      <ThemeProvider locale={theme.locale}>
        <Calendar value={dayjs().toDate()} />
      </ThemeProvider>,
    );
    expect(screen.getByText(placeHolder[theme.type])).toBeTruthy();
  });

  it('should render function locale theme currently', () => {
    const [dialog, contextHolder] = dialogHook;
    render(
      <ThemeProvider locale={EN}>
        {contextHolder}
        <Button
          onClick={() => {
            dialog.confirm({ message: '测试' });
          }}
        >
          Dialog
        </Button>
      </ThemeProvider>,
    );
    userEvent.click(screen.getByText(/Dialog/));
    expect(screen.getByText('Cancel')).toBeTruthy();
  });
});


================================================================================

组件: ThemeProvider
文件: packages/bui-core/src/ThemeProvider/__tests__/mountTokens.test.tsx
========================================

import React from 'react';
import {
  mountTokens,
  mountResponsiveTokens,
  overrideBuiltInThemes,
  rootSelector,
  breakpoints,
} from '..';

let consoleSpy: jest.SpyInstance;
let isValidElement: jest.SpyInstance;
const testId = 'bui-var-bl';

jest.mock('@bifrostui/utils', () => ({
  isMini: false,
}));

beforeEach(() => {
  document.head.innerHTML = '';
  document.body.innerHTML = `<div class="${testId}"></div>`;
});

beforeAll(() => {
  consoleSpy = jest
    .spyOn(global.console, 'error')
    .mockImplementation((message) => {
      if (!message?.message?.includes('Could not parse CSS stylesheet')) {
        global.console.warn(message);
      }
    });

  // mock React.isValidElement
  isValidElement = jest
    .spyOn(React, 'isValidElement')
    .mockImplementation((element) => {
      return element !== null;
    });
});

afterAll(() => {
  consoleSpy.mockRestore();
  isValidElement.mockRestore();
});

describe('MountToken Functions', () => {
  test('mountTokens should not execute when isMini is true', () => {
    jest.mock('@bifrostui/utils', () => ({
      isMini: true,
    }));

    mountTokens();
    expect(document.head.innerHTML).toBe('');
  });

  test('overrideBuiltInThemes', () => {
    const tokenOptions = {
      defaultLightToken: { '--bui-color-red': '#f00' },
      defaultDarkToken: { '--bui-color-fg-default': '#fff' },
      dmLightToken: { '--bui-color-blue': 'blue' },
      dmDarkToken: { '--bui-color-powder-start': 'red' },
    };

    overrideBuiltInThemes(tokenOptions);

    const defaultLightTokenSelector = rootSelector.defaultLight.join(',');
    const defaultDarkTokenSelector = rootSelector.defaultDark.join(',');
    const dmLightTokenSelector = rootSelector.dmLight.join(',');
    const dmtDarkTokenSelector = rootSelector.dmDark.join(',');

    expect(document.head.innerHTML).toContain(defaultLightTokenSelector);
    expect(document.head.innerHTML).toContain('--bui-color-red: #f00;');

    expect(document.head.innerHTML).toContain(defaultDarkTokenSelector);
    expect(document.head.innerHTML).toContain('--bui-color-fg-default: #fff;');

    expect(document.head.innerHTML).toContain(dmLightTokenSelector);
    expect(document.head.innerHTML).toContain('--bui-color-blue: blue;');

    expect(document.head.innerHTML).toContain(dmtDarkTokenSelector);
    expect(document.head.innerHTML).toContain('--bui-color-powder-start: red;');
  });

  test('mountResponsiveTokens with default breakpoints', () => {
    const options = {
      responsive: {
        xs: {
          '--bui-button-border-radius': '2px',
        },
        sm: {
          '--bui-button-border-radius': '6px',
        },
        md: {
          '--bui-button-border-radius': '10px',
        },
        lg: {
          '--bui-button-border-radius': '14px',
        },
        xl: {
          '--bui-button-border-radius': '16px',
        },
      },
    };

    mountResponsiveTokens(options);

    const styleElement = document.head.querySelector('style');
    expect(styleElement).not.toBeNull();

    // check selector
    const defaultLightTokenSelector = rootSelector.defaultLight.join(',');
    expect(styleElement.textContent).toContain(defaultLightTokenSelector);

    // xs
    expect(styleElement.textContent).toContain(
      `@media (max-width: ${breakpoints.xs}) {  --bui-button-border-radius: 2px; }`,
    );
    // sm
    expect(styleElement.textContent).toContain(
      `@media (min-width: ${breakpoints.sm}) {  --bui-button-border-radius: 6px; }`,
    );
    // md
    expect(styleElement.textContent).toContain(
      `@media (min-width: ${breakpoints.md}) {  --bui-button-border-radius: 10px; }`,
    );
    // lg
    expect(styleElement.textContent).toContain(
      `@media (min-width: ${breakpoints.lg}) {  --bui-button-border-radius: 14px; }`,
    );
    // xl
    expect(styleElement.textContent).toContain(
      `@media (min-width: ${breakpoints.xl}) {  --bui-button-border-radius: 16px; }`,
    );
  });

  test('mountResponsiveTokens with custom breakpoints', () => {
    const options = {
      responsive: {
        xs: {
          '--bui-button-border-radius': '2px',
        },
        sm: {
          '--bui-button-border-radius': '6px',
        },
        md: {
          '--bui-button-border-radius': '10px',
        },
        lg: {
          '--bui-button-border-radius': '14px',
        },
        xl: {
          '--bui-button-border-radius': '16px',
        },
      },
      breakpoints: {
        xs: '499.98px',
        sm: '500px',
        md: '800px',
        lg: '1000px',
        xl: '1400px',
      },
    };

    mountResponsiveTokens(options);

    const styleElement = document.head.querySelector('style');
    expect(styleElement).not.toBeNull();

    // check selector
    const defaultLightTokenSelector = rootSelector.defaultLight.join(',');
    expect(styleElement.textContent).toContain(defaultLightTokenSelector);

    // xs
    expect(styleElement.textContent).toContain(
      `@media (max-width: ${options.breakpoints.xs}) {  --bui-button-border-radius: 2px; }`,
    );
    // sm
    expect(styleElement.textContent).toContain(
      `@media (min-width: ${options.breakpoints.sm}) {  --bui-button-border-radius: 6px; }`,
    );
    // md
    expect(styleElement.textContent).toContain(
      `@media (min-width: ${options.breakpoints.md}) {  --bui-button-border-radius: 10px; }`,
    );
    // lg
    expect(styleElement.textContent).toContain(
      `@media (min-width: ${options.breakpoints.lg}) {  --bui-button-border-radius: 14px; }`,
    );
    // xl
    expect(styleElement.textContent).toContain(
      `@media (min-width: ${options.breakpoints.xl}) {  --bui-button-border-radius: 16px; }`,
    );
  });

  test('mountComponentsTokens', () => {
    const tokenOptions = {
      isRoot: false,
      token: {
        '--bui-button-border-radius': '2px',
      },
      containerId: testId,
      container: 'test',
    };

    expect(document.body.innerHTML).toContain('<div class="bui-var-bl"></div>');

    mountTokens(tokenOptions);

    expect(document.body.innerHTML).toContain(
      '<div class="bui-var-bl"><style type="text/css">.bui-var-bl {   --bui-button-border-radius: 2px; }</style></div>',
    );
  });

  afterEach(() => {
    document.body.innerHTML = '';
  });
});


================================================================================

组件: Toast
文件: packages/bui-core/src/Toast/__tests__/Toast.test.tsx
========================================

import React from 'react';
import { act, fireEvent, render, screen } from 'testing';
import { Button } from '@bifrostui/react';
import { ErrorCircleFilledBoldIcon } from '@bifrostui/icons';
import { renderHook } from '@testing-library/react';
import { Toast } from '../index';

describe('Toast', () => {
  const rootClass = 'bui-toast';
  let toastHook;

  beforeEach(() => {
    document.body.innerHTML = '';
    jest.useFakeTimers();
    renderHook(() => {
      toastHook = Toast.useToast();
    });
  });

  afterEach(() => {
    jest.clearAllTimers();
    jest.useRealTimers();
    jest.clearAllMocks();
  });

  it('should render in document body', () => {
    const { getByTestId } = render(
      <Button
        data-testid="emit-button"
        onClick={() => {
          Toast('提示内容');
        }}
      >
        test
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button'));
    expect(document.body.querySelector(`.${rootClass}`)).toBeInTheDocument();
  });

  it('should render whit default props', () => {
    const { getByTestId } = render(
      <Button
        data-testid="emit-button"
        onClick={() => {
          Toast('提示内容');
        }}
      >
        test
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button'));
    expect(document.body.querySelector(`.${rootClass}`)).toHaveClass(
      `${rootClass}-center`,
    );
    expect(document.body.querySelector(`.${rootClass}`)).toHaveClass(
      `${rootClass}-allow-click`,
    );
  });

  it('should destory current Toast when call close function', async () => {
    let toast;
    const { getByTestId } = render(
      <Button
        data-testid="emit-button"
        onClick={() => {
          toast = Toast({
            message: '提示内容',
            duration: 0,
          });
        }}
      >
        test
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button'));
    toast.close();
    await act(async () => {
      await jest.runAllTimers();
    });
    expect(
      document.body.querySelector(`.${rootClass}`),
    ).not.toBeInTheDocument();
  });

  it('should render by warning type', () => {
    const { getByTestId } = render(
      <Button
        data-testid="emit-button-warning"
        onClick={() => {
          Toast.warning('校验不通过，请重试');
        }}
      >
        warning
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button-warning'));
    expect(document.body.querySelector('.bui-svg-icon')).toBeInTheDocument();
    const toastDom = document.body.querySelector(`.${rootClass}`);
    expect(toastDom.innerHTML.includes('校验不通过，请重试')).toBeTruthy();
  });

  it('should render by loading type', () => {
    const { getByTestId } = render(
      <Button
        data-testid="emit-button-loading"
        onClick={() => {
          Toast.loading('正在加载');
        }}
      >
        loading
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button-loading'));
    expect(document.body.querySelector('.bui-svg-icon')).toBeInTheDocument();
    const toastDom = document.body.querySelector(`.${rootClass}`);
    expect(toastDom.innerHTML.includes('正在加载')).toBeTruthy();
  });

  it('should render by success type', () => {
    const { getByTestId } = render(
      <Button
        data-testid="emit-button-success"
        onClick={() => {
          Toast.success('操作成功');
        }}
      >
        success
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button-success'));
    expect(document.body.querySelector('.bui-svg-icon')).toBeInTheDocument();
    const toastDom = document.body.querySelector(`.${rootClass}`);
    expect(toastDom.innerHTML.includes('操作成功')).toBeTruthy();
  });

  it('should render by fail type', () => {
    const { getByTestId } = render(
      <Button
        data-testid="emit-button-fail"
        onClick={() => {
          Toast.fail('操作失败');
        }}
      >
        fail
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button-fail'));
    expect(document.body.querySelector('.bui-svg-icon')).toBeInTheDocument();
    const toastDom = document.body.querySelector(`.${rootClass}`);
    expect(toastDom.innerHTML.includes('操作失败')).toBeTruthy();
  });

  it('should render on different position', () => {
    const { getByTestId } = render(
      <>
        <Button
          data-testid="emit-button-top"
          onClick={() => {
            Toast({
              message: '提示内容',
              position: 'top',
            });
          }}
        >
          test
        </Button>
        <Button
          data-testid="emit-button-center"
          onClick={() => {
            Toast({
              message: '提示内容',
              position: 'center',
            });
          }}
        >
          test
        </Button>
        <Button
          data-testid="emit-button-bottom"
          onClick={() => {
            Toast({
              message: '提示内容',
              position: 'bottom',
            });
          }}
        >
          test
        </Button>
      </>,
    );
    fireEvent.click(getByTestId('emit-button-top'));
    expect(
      document.body.querySelector(`.${rootClass}-top`),
    ).toBeInTheDocument();

    fireEvent.click(getByTestId('emit-button-center'));
    expect(
      document.body.querySelector(`.${rootClass}-center`),
    ).toBeInTheDocument();

    fireEvent.click(getByTestId('emit-button-bottom'));
    expect(
      document.body.querySelector(`.${rootClass}-bottom`),
    ).toBeInTheDocument();
  });

  it('should render multiple toast as same time', () => {
    const { getByTestId } = render(
      <>
        <Button
          data-testid="emit-button-top"
          onClick={() => {
            Toast({
              message: '提示内容',
              position: 'top',
              allowMultiple: true,
            });
          }}
        >
          test
        </Button>
        <Button
          data-testid="emit-button-center"
          onClick={() => {
            Toast({
              message: '提示内容',
              position: 'center',
              allowMultiple: true,
            });
          }}
        >
          test
        </Button>
      </>,
    );
    fireEvent.click(getByTestId('emit-button-top'));
    fireEvent.click(getByTestId('emit-button-center'));
    expect(document.body.innerHTML.split('提示内容').length - 1).toBe(2);
  });

  it('should render with custom icon', () => {
    const { getByTestId } = render(
      <Button
        data-testid="emit-button"
        onClick={() => {
          Toast({
            icon: (
              <ErrorCircleFilledBoldIcon
                data-testid="test-icon"
                htmlColor="#ffffff"
              />
            ),
            message: '提示内容',
          });
        }}
      >
        test
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button'));
    expect(getByTestId('test-icon')).toBeInTheDocument();
  });

  it('should forbid click event on background page', () => {
    const { getByTestId } = render(
      <Button
        data-testid="emit-button"
        onClick={() => {
          Toast({
            message: '提示内容',
            disableClick: true,
          });
        }}
      >
        test
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button'));
    const toastDom = document.body.querySelector(`.${rootClass}`);
    expect(toastDom.parentNode).toHaveStyle(
      'position: fixed; top: 0px; bottom: 0px; left: 0px; right: 0px; z-index: var(--bui-z-index-toast);',
    );
  });

  it('should call onClose when Toast hidden', async () => {
    const fn = jest.fn();
    const { getByTestId } = render(
      <Button
        data-testid="emit-button"
        onClick={() => {
          Toast({
            message: '提示内容',
            onClose: fn,
          });
        }}
      >
        test
      </Button>,
    );
    fireEvent.click(getByTestId('emit-button'));
    await act(async () => {
      await jest.runAllTimers();
    });
    expect(fn).toBeCalled();
  });

  it('should destory all Toast when call clear function', async () => {
    const { getByTestId } = render(
      <>
        <Button
          data-testid="emit-button1"
          onClick={() => {
            Toast({
              message: '提示内容',
              allowMultiple: true,
              duration: 0,
            });
          }}
        >
          test
        </Button>
        <Button
          data-testid="emit-button2"
          onClick={() => {
            Toast({
              message: '提示内容',
              allowMultiple: true,
              duration: 0,
            });
          }}
        >
          test
        </Button>
        <Button
          data-testid="emit-button3"
          onClick={() => {
            Toast.clear();
          }}
        >
          test
        </Button>
      </>,
    );
    fireEvent.click(getByTestId('emit-button1'));
    fireEvent.click(getByTestId('emit-button2'));
    expect(document.body.innerHTML.split('提示内容').length - 1).toBe(2);
    fireEvent.click(getByTestId('emit-button3'));
    await act(async () => {
      await jest.runAllTimers();
    });
    expect(document.body.innerHTML.includes('提示内容')).toBeFalsy();
  });
  it.each(['warning', 'loading', 'success', 'fail', 'clear'])(
    'should support basic api with useToast',
    async (type) => {
      const toast = toastHook?.[0];
      if (type === 'clear') {
        render(
          <>
            <Button
              onClick={() => {
                toast({
                  message: '提示内容',
                  allowMultiple: true,
                  duration: 0,
                });
              }}
            >
              button one
            </Button>
            <Button
              onClick={() => {
                toast({
                  message: '提示内容',
                  allowMultiple: true,
                  duration: 0,
                });
              }}
            >
              button two
            </Button>
            <Button
              onClick={() => {
                toast.clear();
              }}
            >
              button three
            </Button>
          </>,
        );
        fireEvent.click(screen.getByText('button one'));
        fireEvent.click(screen.getByText('button two'));
        expect(document.body.innerHTML.split('提示内容').length - 1).toBe(2);
        fireEvent.click(screen.getByText('button three'));
        await act(async () => {
          await jest.runAllTimers();
        });
        expect(document.body.innerHTML.includes('提示内容')).toBeFalsy();
      } else {
        render(
          <Button
            onClick={() => {
              toast[type](`校验${type}`);
            }}
          >
            {`${type} button`}
          </Button>,
        );
        fireEvent.click(screen.getByText(`${type} button`));
        expect(
          document.body.querySelector('.bui-svg-icon'),
        ).toBeInTheDocument();
        const toastDom = document.body.querySelector(`.${rootClass}`);
        expect(toastDom.innerHTML.includes(`校验${type}`)).toBeTruthy();
      }
    },
  );
});


================================================================================

组件: Tooltip
文件: packages/bui-core/src/Tooltip/__tests__/Tooltip.test.tsx
========================================

import React from 'react';
import { isConformant, render, screen, userEvent, fireEvent } from 'testing';
import Tooltip from '../index';

const directions = [
  'top',
  'left',
  'right',
  'bottom',
  'topLeft',
  'topRight',
  'bottomLeft',
  'bottomRight',
  'leftTop',
  'leftBottom',
  'rightTop',
  'rightBottom',
];
const rootClass = 'bui-tooltip';

describe('Tooltip', () => {
  isConformant({
    Component: Tooltip,
    displayName: 'BuiTooltip',
    className: rootClass,
    skip: [
      'component-has-root-ref',
      'component-handles-classNames',
      'component-has-default-className',
      'component-handles-style',
    ],
  });

  it('test open props', () => {
    const onOpenChange = jest.fn();
    render(
      <Tooltip title="This is a tooltip2" open onOpenChange={onOpenChange}>
        <div data-testid="tooltipTestid">children</div>
      </Tooltip>,
    );
    expect(screen.getByText('This is a tooltip2')).toBeInTheDocument();

    const $childrenDom = screen.getByTestId('tooltipTestid');
    userEvent.click($childrenDom);
    expect(onOpenChange).toHaveBeenCalledTimes(0);
  });

  directions.forEach((placement) => {
    it(`test placement props the ${placement}`, () => {
      render(
        // @ts-ignore
        <Tooltip title="This is a tooltip3" defaultOpen placement={placement}>
          <div>children</div>
        </Tooltip>,
      );
      const direction = placement.split(/[A-Z]/)[0];
      const $dom = document.querySelector('.bui-tooltip');
      expect($dom).toHaveClass(`tooltip-${direction}`);
    });
  });

  it('test trigger onOpenChange props', () => {
    const onOpenChange = jest.fn();
    render(
      <Tooltip
        title="This is a tooltip4"
        defaultOpen
        trigger={['click', 'hover']}
        onOpenChange={onOpenChange}
      >
        <div data-testid="tooltipTestid">children</div>
      </Tooltip>,
    );
    const $childrenDom = screen.getByTestId('tooltipTestid');
    userEvent.click($childrenDom);
    expect(onOpenChange).toHaveBeenCalled();
  });

  it('test trigger click anywhere hide props', () => {
    const onOpenChange = jest.fn();
    render(
      <Tooltip
        title="This is a tooltip4"
        defaultOpen
        trigger="click"
        onOpenChange={onOpenChange}
      >
        <div data-testid="tooltipTestid">children</div>
      </Tooltip>,
    );
    // const $childrenDom = screen.getByTestId('tooltipTestid');
    userEvent.click(document.body);
    expect(onOpenChange).toHaveBeenCalled();
  });

  it('test trigger hover onOpenChange props', () => {
    const onOpenChange = jest.fn();
    render(
      <Tooltip
        title="This is a tooltip4"
        defaultOpen
        trigger={['hover']}
        onOpenChange={onOpenChange}
      >
        <div data-testid="tooltipTestid">children</div>
      </Tooltip>,
    );
    const $childrenDom = screen.getByTestId('tooltipTestid');
    fireEvent.mouseEnter($childrenDom);
    fireEvent.mouseLeave($childrenDom);
    expect(onOpenChange).toBeCalledTimes(2);
    // 代表不触发隐藏
    userEvent.click(document.body);
    expect(onOpenChange).toBeCalledTimes(2);
  });
});

describe('Tooltip', () => {
  isConformant({
    Component: Tooltip,
    displayName: 'BuiTooltip',
    className: rootClass,
    skip: [
      'component-has-root-ref',
      'component-handles-classNames',
      'component-has-default-className',
      'component-handles-style',
    ],
  });

  it('renders correctly', () => {
    // mock位置
    const mockGetBoundingClientRect = jest.fn().mockReturnValue({
      width: 100,
      height: 50,
      top: 10,
      left: 0,
      right: 100,
      bottom: 50,
    });
    Object.defineProperty(
      window.HTMLElement.prototype,
      'getBoundingClientRect',
      {
        configurable: true,
        value: mockGetBoundingClientRect,
      },
    );
    render(
      <Tooltip title="This is a tooltip" defaultOpen>
        <div data-testid="tooltipTestid">children</div>
      </Tooltip>,
    );

    expect(screen.getByText('This is a tooltip')).toBeInTheDocument();
  });

  it('renders correctly offset cacl topCenter', () => {
    // mock位置
    const mockGetBoundingClientRect = jest.fn().mockReturnValue({
      width: 100,
      height: 50,
      top: 10,
      left: 50,
      right: 50,
      bottom: 50,
    });
    Object.defineProperty(
      window.HTMLElement.prototype,
      'getBoundingClientRect',
      {
        configurable: true,
        value: mockGetBoundingClientRect,
      },
    );

    Object.defineProperty(document.documentElement, 'clientWidth', {
      get: () => {
        return 375;
      },
    });

    render(
      <Tooltip title="This is a tooltip" defaultOpen>
        <div data-testid="tooltipTestid">children</div>
      </Tooltip>,
    );

    expect(screen.getByText('This is a tooltip')).toBeInTheDocument();
  });

  it('renders correctly offset cacl leftCenter', () => {
    // mock位置
    const mockGetBoundingClientRect = jest.fn().mockReturnValue({
      width: 100,
      height: 50,
      top: 10,
      left: 50,
      right: 50,
      bottom: 20,
    });
    Object.defineProperty(
      window.HTMLElement.prototype,
      'getBoundingClientRect',
      {
        configurable: true,
        value: mockGetBoundingClientRect,
      },
    );

    Object.defineProperty(document.documentElement, 'clientHeight', {
      get: () => {
        return 667;
      },
    });

    render(
      <Tooltip title="This is a tooltip" placement="left" defaultOpen>
        <div data-testid="tooltipTestid">children</div>
      </Tooltip>,
    );

    expect(screen.getByText('This is a tooltip')).toBeInTheDocument();
  });
});


================================================================================

组件: Transition
文件: packages/bui-core/src/Transition/__test__/Transition.test.tsx
========================================

import React from 'react';
import { render, screen, waitFor } from 'testing';
import { Transition } from '../Transition';

describe('Transition', () => {
  it('will change status and execute callbacks by in prop', async () => {
    const ons = {
      onEnter: jest.fn(),
      onEntering: jest.fn(),
      onEntered: jest.fn(),
      onExit: jest.fn(),
      onExiting: jest.fn(),
      onExited: jest.fn(),
    };
    const renderFn = (s) => <div data-testid="status">{s}</div>;
    const { rerender } = render(
      <Transition {...ons} in={false} timeout={10}>
        {renderFn}
      </Transition>,
    );
    expect(screen.getByTestId('status')).toHaveTextContent('exited');
    expect(ons.onEnter).not.toBeCalled();
    rerender(
      <Transition {...ons} in timeout={10}>
        {renderFn}
      </Transition>,
    );
    await waitFor(() => {
      expect(ons.onEnter).toBeCalled();
      expect(ons.onEntering).not.toBeCalled();
    });

    await waitFor(() => {
      expect(screen.getByTestId('status')).toHaveTextContent('entering');
    });
    await waitFor(() => {
      expect(ons.onEntering).toBeCalled();
      expect(ons.onEntered).not.toBeCalled();
    });

    await waitFor(() => {
      expect(screen.getByTestId('status')).toHaveTextContent('entered');
    });
    await waitFor(() => {
      expect(ons.onEntered).toBeCalled();
      expect(ons.onExit).not.toBeCalled();
    });

    rerender(
      <Transition {...ons} in={false} timeout={10}>
        {renderFn}
      </Transition>,
    );
    await waitFor(() => {
      expect(ons.onExit).toBeCalled();
      expect(ons.onExiting).not.toBeCalled();
    });
    await waitFor(() => {
      expect(screen.getByTestId('status')).toHaveTextContent('exiting');
    });
    await waitFor(() => {
      expect(ons.onExiting).toBeCalled();
      expect(ons.onExited).not.toBeCalled();
    });
    await waitFor(() => {
      expect(screen.getByTestId('status')).toHaveTextContent('exited');
    });
    await waitFor(() => {
      expect(ons.onExited).toBeCalled();
    });
  });

  it('will appear', async () => {
    const ons = {
      onEnter: jest.fn(),
      onEntering: jest.fn(),
      onEntered: jest.fn(),
      onExit: jest.fn(),
      onExiting: jest.fn(),
      onExited: jest.fn(),
    };
    const renderFn = (s) => <div data-testid="status">{s}</div>;
    render(
      <Transition {...ons} in appear timeout={10}>
        {renderFn}
      </Transition>,
    );
    expect(screen.getByTestId('status')).toHaveTextContent('exited');
    expect(ons.onEnter).not.toBeCalled();
    expect(ons.onEntering).not.toBeCalled();
    await waitFor(() => {
      expect(ons.onEnter).toBeCalled();
    });
    await waitFor(() => {
      expect(screen.getByTestId('status')).toHaveTextContent('entering');
    });
    await waitFor(() => {
      expect(ons.onEntering).toBeCalled();
      expect(ons.onEntered).not.toBeCalled();
    });
    await waitFor(() => {
      expect(screen.getByTestId('status')).toHaveTextContent('entered');
    });
    await waitFor(() => {
      expect(ons.onEntered).toBeCalled();
    });
  });

  it('will unmountOnExit', async () => {
    const renderFn = (s) => <div data-testid="status">{s}</div>;
    const { rerender } = render(
      <Transition in={false} timeout={10} unmountOnExit>
        {renderFn}
      </Transition>,
    );
    expect(screen.queryByTestId('status')).toBeNull();
    rerender(
      <Transition in timeout={10} unmountOnExit>
        {renderFn}
      </Transition>,
    );
    await waitFor(() => {
      expect(screen.getByTestId('status')).toHaveTextContent('entering');
    });
    await waitFor(() => {
      expect(screen.getByTestId('status')).toHaveTextContent('entered');
    });
    rerender(
      <Transition in={false} timeout={10} unmountOnExit>
        {renderFn}
      </Transition>,
    );
    await waitFor(() => {
      expect(screen.getByTestId('status')).toHaveTextContent('exiting');
    });
    await waitFor(() => {
      expect(screen.queryByTestId('status')).toBeNull();
    });
  });
  it('will mountOnEnter', async () => {
    const renderFn = (s) => <div data-testid="status">{s}</div>;
    const { rerender } = render(
      <Transition in={false} timeout={10} mountOnEnter>
        {renderFn}
      </Transition>,
    );
    expect(screen.queryByTestId('status')).toBeNull();
    rerender(
      <Transition in timeout={10} mountOnEnter>
        {renderFn}
      </Transition>,
    );
    await waitFor(() => {
      expect(screen.getByTestId('status')).toHaveTextContent('entering');
    });
    await waitFor(() => {
      expect(screen.getByTestId('status')).toHaveTextContent('entered');
    });
    rerender(
      <Transition in={false} timeout={10} mountOnEnter>
        {renderFn}
      </Transition>,
    );
    await waitFor(() => {
      expect(screen.getByTestId('status')).toHaveTextContent('exiting');
    });
    await waitFor(() => {
      expect(screen.queryByTestId('status')).toHaveTextContent('exited');
    });
  });
});
